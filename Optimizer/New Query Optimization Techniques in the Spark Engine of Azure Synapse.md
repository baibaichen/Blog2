# New Query Optimization Techniques in the Spark Engine of Azure Synapse

## 2 MOTIVATION AND EXAMPLES
We begin with a performance characterization of Spark.



### 2.1 Workload characterization

We enhanced the instrumentation done by Spark to measure the time spent in each operator1 by each task. Figure 2 reports the time spent in various operators for the most expensive 20 queries in TPCDS (at 1TB scale factor). For each query it shows the breakdown before and after our optimizations, we focus on the cost before (left bar) in this section. We make the following observations.

- **Exchange**, hash-aggregate and sort are the three most expensive operators. They contribute to 80% of the total task time in half the queries and 50 âˆ’ 80% in another quarter of the queries.
- **Exchange** is uniformly expensive and contributes 20 âˆ’ 40% of the cost in all but a few ( 5%) scan heavy queries.
- Sort and hash-aggregate are almost equally expensive, they together contribute 20 âˆ’ 50% of cost in most queries.
- Scan and Join, the other two significant operators are much less expensive on average. However, they are the most expensive operator in specific queries (like ğ‘„88 and ğ‘„95 respectively).

### 2.2 Examples of optimizations
Next we motivate the proposed optimizations with examples from TPCDS. Table 1 describes the notation we use to represent queries.

2.2.1 **Exchange placement**. Consider a variant of Q23 (we show only 2 of the 4 subtrees and modify some operators for ease of exposition) as shown in Figure 3. The tree shows operators as nodes and their required partitioning properties annotated on edges. In case there are multiple possibilities the edge is annotated with a set of partitioning options, any one of which would suffice. For example, edge ğ‘’4 requires partitioning on either the pair of columns ğ‘1, ğ‘1 or just ğ‘1 or just ğ‘1. All these are valid options as key based operators (join, group-by etc.) can execute in parallel as long as inputs are partitioned on some subset of the keys. Notice that the query performs ğ‘‡1 âŠ²âŠ³ ğ‘‡2 twice but with different parent operators.

An exchange operator takes as input a set of columns (and a partition count) and partitions the data on those columns. Figure 4 shows two ways of placing exchanges in this query. The plan on the left is generated by state-of-the-art algorithms that minimize the number of exchanges needed to satisfy the required properties of all the operators. To do so it picks partitioning options at edges such that they can be satisfied by exchanges introduced lower in the tree. For example, if we pick a partitioning option ğ‘1 at ğ‘’8, it can be satisfied by the previous exchange on ğ‘1 at ğ‘’6 (we use shorthand ğ‘’6 â†ğ‘1 to represent exchange assignments). Similarly if the partitioning option ğ‘1 at ğ‘’4 is chosen, it can make use of ğ‘’1 â† ğ‘1. **We refer to the careful choice of picking partitioning options to use a previous exchange as overlapping an exchange**. Such an assignment would lead to six exchanges (at all but ğ‘’8 and ğ‘’4). For this example, the above assignment is minimal in the number of exchanges needed to satisfy partitioning requirements of all operators. The exchange reuse rule would then trim this list down to 4 (Figure 4(a) shows the final plan). Note that in this plan the join between ğ‘‡1 and ğ‘‡2 is performed twice and the exchanges after ğ‘‡1 and ğ‘‡2 are reused and each is read by two consumer stages.

> æˆ‘ä»¬å°†è°¨æ…é€‰æ‹©åˆ†åŒºé€‰é¡¹ä»¥ä½¿ç”¨å‰ä¸€ä¸ªäº¤æ¢ç§°ä¸ºé‡å äº¤æ¢ã€‚

However as shown in Figure 4(b) there is another assignment which overlaps fewer exchanges but is better. Consider the plan when only exchange ğ‘’3 â†ğ‘3 is overlapped (with ğ‘’5). This would lead to seven exchange assignments (before reuse exchange). Notice here we deliberately pick the partitioning choice ğ‘1 at ğ‘’8 and this is clearly sub-optimal from an exchange overlap perspective. Despite this we get a better plan after the reuse exchange rule is applied (as shown in Figure 4(b)). This plan directly reuses the exchange ğ‘’4 â†ğ‘1 at ğ‘’8 (thus reusing the result of the join) to generate a plan with 4 exchanges.As this is a deeper exchange reuse, this planwould not only avoid exchanges at ğ‘’6, ğ‘’7 and ğ‘’8 but also avoid performing the join a second time. Further note that this plan would also likely lead to lesser I/O as only one exchange is reused as opposed to two (2 reads instead of 4). Hence overall we expect this plan to be better.

In summary, combining exchange reuse opportunities with exchange overlap produces better plans, this is the focus of the exchange placement algorithm we propose.

## 3 EXCHANGE PLACEMENT

This section describes the exchange placement algorithm we use in synapse spark. Figure 7 provides an overview of what existing systems do today and our proposal. Broadly there are two kinds of systems. Scope [35], employs cost based exploration to select among different exchange placement options [34]. As we describe later such exploration allows it to maximally overlap exchanges. On the other hand systems like Spark do not support exploration and instead maintain just a single plan. They traverse the plan bottom up and introduce exchanges after performing a local overlap check. As shown in the figure, both systems apply the **exchange reuse rule** separately, after exchange placement. In both systems, it transforms the final chosen plan without exploration.

In synapse spark we perform exchange placement in a cost based manner, while taking into account both exchange overlap and exchange reuse opportunities. Now, cost based exploration can be expensive, and Scope employs a large optimization time budget (several minutes). In synapse spark on the other-hand we impose a hard constraint on the optimizer time (in seconds) to meet customers expectations. To achieve this we improve the state-ofthe-art algorithm that has a large exploration space (Section 3.1). We do so by exploring multiple options only when there are multiple ways to overlap exchanges or when exchange overlap conflicts with exchange reuse (Section 3.2). Finally, to determine conflicting options, we need to identify potential for exchange reuse early. We employ plan marking for this (Section 3.3).

> æœ¬èŠ‚ä»‹ç»æˆ‘ä»¬åœ¨ synapse spark ä¸­ä½¿ç”¨çš„  exchange placement ç®—æ³•ã€‚ å›¾ 7 æ¦‚è¿°äº†å½“ä»Šç°æœ‰ç³»ç»Ÿçš„åŠŸèƒ½ä»¥åŠæˆ‘ä»¬çš„å»ºè®®ã€‚å¤§è‡´æœ‰ä¸¤ç§ç³»ç»Ÿã€‚Scope [35] é‡‡ç”¨åŸºäºæˆæœ¬çš„æ¢ç´¢æ¥é€‰æ‹©ä¸åŒçš„ exchange placement[34]ã€‚æ­£å¦‚æˆ‘ä»¬ç¨åæè¿°çš„é‚£æ ·ï¼Œè¿™ç§æ¢ç´¢å…è®¸å®ƒæœ€å¤§ç¨‹åº¦åœ°é‡å äº¤æ¢ã€‚å¦ä¸€æ–¹é¢ï¼Œåƒ Spark è¿™æ ·çš„ç³»ç»Ÿä¸æ”¯æŒæ¢ç´¢ï¼Œè€Œæ˜¯åªç»´æŠ¤ä¸€ä¸ªè®¡åˆ’ã€‚ä»–ä»¬è‡ªä¸‹è€Œä¸Šéå†è®¡åˆ’å¹¶åœ¨æ‰§è¡Œ**å±€éƒ¨é‡å æ£€æŸ¥**åå¼•å…¥ Exchangeã€‚ å¦‚å›¾æ‰€ç¤ºï¼Œä¸¤ä¸ªç³»ç»Ÿåœ¨ exchange placement ååˆ†åˆ«åº”ç”¨**äº¤æ¢é‡ç”¨è§„åˆ™**ã€‚ åœ¨è¿™ä¸¤ä¸ªç³»ç»Ÿä¸­ï¼Œå®ƒæ— éœ€æ¢ç´¢å³å¯è½¬æ¢æœ€ç»ˆé€‰æ‹©çš„è®¡åˆ’ã€‚
>
> åœ¨ synapse spark ä¸­ï¼Œæˆ‘ä»¬ä»¥åŸºäºæˆæœ¬çš„æ–¹å¼æ‰§è¡Œ exchange placementï¼ŒåŒæ—¶è€ƒè™‘äº¤æ¢é‡å å’Œäº¤æ¢é‡ç”¨æœºä¼šã€‚ç›®å‰åŸºäºæˆæœ¬çš„æ¢ç´¢å¯èƒ½å¾ˆæ˜‚è´µï¼Œè€Œ Scope ä½¿ç”¨äº†å¾ˆå¤§çš„ä¼˜åŒ–æ—¶é—´é¢„ç®—ï¼ˆå‡ åˆ†é’Ÿï¼‰ã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬å¯¹ synapse spark ä¼˜åŒ–å™¨æ—¶é—´æ–½åŠ äº†ç¡¬çº¦æŸï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ï¼Œä»¥æ»¡è¶³å®¢æˆ·çš„æœŸæœ›ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬æ”¹è¿›äº†å…·æœ‰è¾ƒå¤§æ¢ç´¢ç©ºé—´çš„**ç°æœ‰**ç®—æ³•ï¼ˆç¬¬3.1èŠ‚ï¼‰ã€‚åªæœ‰å½“æœ‰å¤šç§æ–¹å¼é‡å äº¤æ¢æˆ–äº¤æ¢é‡å ä¸äº¤æ¢é‡ç”¨å†²çªæ—¶ï¼Œæˆ‘ä»¬æ‰ä¼šæ¢ç´¢å¤šä¸ªé€‰é¡¹ï¼ˆç¬¬3.2èŠ‚ï¼‰ã€‚æœ€åï¼Œä¸ºäº†ç¡®å®šç›¸äº’å†²çªçš„é€‰é¡¹ï¼Œæˆ‘ä»¬éœ€è¦å°½æ—©è¯†åˆ«äº¤æ¢é‡ç”¨çš„å¯èƒ½æ€§ã€‚æˆ‘ä»¬ä¸ºæ­¤é‡‡ç”¨äº†è®¡åˆ’æ ‡è®°ï¼ˆç¬¬3.3èŠ‚ï¼‰ã€‚

### 3.1 Exploration based exchange placement
Lets begin by examining the state-of-the-art algorithm for exchange placement [34]. Algorithm 1 shows pseudo-code for a recursive routine that computes the interesting partitioning options at each operator in the plan. For ease of exposition, we assume that the plan only consists of key based operators. The implementation of course deals with all SQL operators. First, we define Pâ€²(X) = P(X) \ âˆ… where P(X) is the **power set of X**. In the this section when we mention power set, we refer to Pâ€². Now in this method, the interesting partitioning options consists of all possible combinations of the operator keys i.e. Pâ€²(plan.keys). In Figure 3, the join having {ğ‘1, ğ‘1} as keys, would have {ğ‘1 |ğ‘1 |ğ‘1, ğ‘1} in its `iKeysSet`.

Next, plans with different combinations of partition keys are explored using a standard plan space exploration algorithm. Algorithm 2 shows a simplified version of the dynamic programming based exploration algorithm used in both synapse spark and Scope^2^. The algorithm tracks up to ğ‘˜ plans per node. We discuss how ğ‘˜ is chosen at the end of the section.

> 2. There are several differences in the specifics of the algorithm used by the two systems. We focus here on exchange placement relevant aspects.

In line 2, for each interesting partitioning key `partnKeys` of this operator, the best (up to ğ‘˜) plans for its children are computed first. Next, these alternative plans from the children are combined to get the alternative plans for the current operator. For example, if the plan has two children ğ¶1 and ğ¶2, **having two and three top plans** respectively, there would be six alternative options - plan having children as $\{\{C_{1}^{1}, C_{2}^{1}\},\{C_{1}^{1}, C_{2}^{2}\},\{C_{1}^{1}, C_{2}^{3}\},\{C_{1}^{2}, C_{2}^{1}\},\{C_{1}^{2}, C_{2}^{2}\},\{C_{1}^{2}, C_{2}^{3}\}\}$. This is followed by iterating over these alternatives, adding exchanges (using `EnforceExchange` at line 9) and selecting the top ğ‘˜ plans having minimum cost. EnforceExchange, as explained in more detail in [34], inserts an exchange only if the child partitioning does not satisfy the partitioning option at the parent. Specifically it checks for **exchange overlap**, that is whether the child partitioning is a (non-empty) subset of the partitioning option being explored.

This algorithm is exhaustive in the enumeration of interesting partitioning options. Scope, the existing system that uses the algorithm, can afford to employ a large value of ğ‘˜ (as it has a large time budget). This ensures that it is able to produce maximum overlap plans like the one shown in Figure 4(a).

### 3.2 Pruning the space with overlap reasoning

Algorithm 3 describes our implementation to prune the exploration space by reducing the partitioning options (lines 5-7). Instead of relying on `EnforceExchange` to detect overlap opportunities, we prune the options in two phases. First, we compute individual partitioning keys of the operator that have an overlap with its parentâ€™s or childrenâ€™s keys. We add^3^ all of them to set `iKeys`

> 3. X.addAll(Y) indicates adding all elements from Set Y to Set X. X.add(Y) indicates adding the Set Y to Set X as a single entity.

In the second phase, we obtain all overlap options by intersecting the power set of iKeys with the power set of parentâ€™s keys and the childrenâ€™s keys. We insert only these as options (in iKeySet) using a `checkAndAddAll` method. This method checks if the number of distinct values for the set is more than the number of partitions required (a job parameter) before adding it as a partitioning option. Table 2 demonstrates how this adds all overlap options. The third row (labeled Total) has 3 different ways to overlap between parent (P1) and child (ST1), all these are added as options. Row Partial (representative of example in Figure 3) only adds one option. This is sufficient to produce maximal overlap plan Figure 4(a). Finally, if no options are added based on overlap (row None in table), we only consider one option which is the entire key set (line 20). This pruning reduces the search space significantly whenever operators are keyed on multiple columns (like in TPCDS queries).



### 3.3 Incorporating exchange reuse

> As we saw in Section 2.2.1 exchange reuse can conflict with exchange overlap. This happens when there is an overlap between partitioning keys of the reusable sub-tree and its parent. For example, in Figure 3, there is an overlap in the partitioning keys of join having keys {ğ‘1} and its parent join having keys {ğ‘1, ğ‘1}. If we simply maximize overlap we may not introduce an exchange after the join at all and hence there would be no scope for an exchange reuse (after **join**).
>
> To resolve this, ==we will have to include additional keys in the interesting partitioning options (`iKeysSet`) tracked at the parents of the reusable sub-trees==. We accomplish this in two steps.
>
> We begin by executing a new **routine** before Algorithm 3 which is described in Algorithm 4. This algorithm adds **plan markers** at nodes in the tree such that if two nodes have the same marker value, **the sub-trees rooted on them are identical**. In addition to it, we use a `reuseMap`, to store <u>the partitioning keys from these identical subtreesâ€™ parent</u>. This algorithm is followed by a cleanup routine (not shown) that removes **singleton entries** from the `reuseMap`.
>
> Next, we extend Algorithm 3 to support exchange reuse by adding the common keys (derived from `reuseMap`) in the interesting partitioning keys set if the child is a reusable sub-tree (lines 13-16).

æ­£å¦‚æˆ‘ä»¬åœ¨ 2.2.1 èŠ‚ä¸­çœ‹åˆ°çš„ï¼Œ**äº¤æ¢é‡ç”¨**å¯èƒ½ä¸**äº¤æ¢é‡å **å‘ç”Ÿå†²çªã€‚å½“å¯é‡ç”¨å­èŠ‚ç‚¹çš„åˆ†åŒºé”®ä¸å…¶èŠ‚ç‚¹ä¹‹é—´å­˜åœ¨é‡å æ—¶ï¼Œå°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚ä¾‹å¦‚ï¼Œåœ¨å›¾ 3 ä¸­ï¼Œå…·æœ‰é”® {ğ‘1} çš„ Join çš„åˆ†åŒºé”®ä¸å…¶å…·æœ‰é”® {ğ‘1ï¼Œğ‘1} çš„çˆ¶ Join çš„åˆ†åŒºé”®å­˜åœ¨é‡å ã€‚å¦‚æœæˆ‘ä»¬åªæ˜¯æœ€å¤§åŒ–é‡å ï¼Œæˆ‘ä»¬å¯èƒ½æ ¹æœ¬ä¸ä¼šåœ¨ Join ä¹‹åå¼•å…¥ Shuffleï¼Œå› æ­¤ï¼ˆåœ¨ **Join** ä¹‹åï¼‰æ²¡æœ‰äº¤æ¢é‡ç”¨çš„ç©ºé—´ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ==åœ¨å¯é‡ç”¨å­æ ‘çš„çˆ¶èŠ‚ç‚¹ä¸Šè·Ÿè¸ªçš„**æœ‰è¶£åˆ†åŒºé€‰é¡¹**ï¼ˆ`iKeysSet`ï¼‰ä¸­ï¼Œå¿…é¡»åŒ…å«é¢å¤–çš„é”®==ã€‚æˆ‘ä»¬åˆ†ä¸¤æ­¥å®Œæˆã€‚

æˆ‘ä»¬é¦–å…ˆåœ¨ç®—æ³• 3 ä¹‹å‰æ‰§è¡Œä¸€ä¸ªæ–°çš„**ä¾‹ç¨‹**ï¼Œåœ¨ç®—æ³• 4 ä¸­æè¿°ã€‚è¯¥ç®—æ³•åœ¨æ ‘ä¸­çš„èŠ‚ç‚¹å¤„æ·»åŠ **è®¡åˆ’æ ‡è®°**ï¼Œè¿™æ ·å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„æ ‡è®°å€¼ï¼Œ**åˆ™ä»¥å®ƒä»¬ä¸ºæ ¹çš„å­æ ‘ç›¸åŒ**ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬ä½¿ç”¨ `reuseMap` æ¥å­˜å‚¨<u>æ¥è‡ªè¿™äº›ç›¸åŒå­æ ‘çˆ¶èŠ‚ç‚¹çš„åˆ†åŒºé”®</u>ã€‚è¯¥ç®—æ³•ä¹‹åæ˜¯ä¸€ä¸ªæ¸…ç†ä¾‹ç¨‹ï¼ˆæœªæ˜¾ç¤ºï¼‰ï¼Œè¯¥ä¾‹ç¨‹ä» `reuseMap` ä¸­åˆ é™¤**å•ä¾‹æ¡ç›®**ã€‚

æ¥ä¸‹æ¥ï¼Œå¦‚æœå­æ ‘æ˜¯å¯é‡ç”¨çš„å­æ ‘ï¼ˆç¬¬ 13-16 è¡Œï¼‰ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨==**æœ‰è¶£çš„åˆ†åŒºé”®é›†**==ä¸­æ·»åŠ å…¬å…±é”®ï¼ˆæ´¾ç”Ÿè‡ª `reuseMap`ï¼‰æ¥æ‰©å±•ç®—æ³• 3 ä»¥æ”¯æŒ**äº¤æ¢é‡ç”¨**ã€‚

Lets revisit row `Partial` in Table 2. Consider the two nodes at (ğ‘†ğ‘‡1, ğ‘†ğ‘‡2) at âŠ²âŠ³ğ‘1=ğ‘2 (ğ‘‡1,ğ‘‡2) in Figure 3 and their parents (ğ‘ƒ1, ğ‘ƒ2). We already established that their `iKeysSet` based on overlap reasoning would contain one element ğ‘1. Now in order to take reuse into account, we will add the common keys between the ğ‘ƒ1 and ğ‘ƒ2 in their `iKeysSet`. Thus, the parentsâ€™ new `iKeysSet` would be {ğ‘1 |ğ‘1}. The exploration will now include exchange on ğ‘1 as an option. If costed right this should lead to the plan shown in Figure 4(b).

Since, we are depending on the costing model for the keys selection, we need to ensure that during costing we take exchange reuse into account. To accomplish this, we add a sub-routine `AddReuseExchange` after line 9 in Algorithm 2. At this point, optPlan would contain exchange operators at the required places, added by `EnforceExchange`. Since we have previously accomplished plan-marking, AddReuseExchange will identify exchange operators, whose children are marked for reuse. Now, for each group (consisting of identical sub-trees), it replaces all except one such exchange operators by exchange reuse operators in the optPlan. We will now use this optPlanWithReuse while updating the operatorâ€™s top k plans set.

```
optPlanWithReuse â† AddReuseExchange(optPlan)
```

> In summary, synapse spark incorporates cost based exploration to decide on the placement of exchanges. By detecting exchange reuse opportunity early and by using this along with overlap information it is able to prune the search space significantly to make exploration practical. Specifically, in synapse spark we desire to optimize every query within 30 seconds.We achieve this by dynamically choosing the values of ğ‘˜ based on the complexity of the query. We observe that because of pruning a value of ğ‘˜ = 4 is sufficient to find the optimal exchange placement for all queries. We show in Section 7.4 that a value above 16 (as would be needed without pruning) significantly slows down the optimizer.

æ€»ä¹‹ï¼Œ**synapse spark** ç»“åˆäº†åŸºäºæˆæœ¬çš„æ¢ç´¢æ¥å†³å®šäº¤æ¢çš„ä½ç½®ã€‚é€šè¿‡å°½æ—©å‘ç°äº¤æ¢é‡ç”¨æœºä¼šï¼Œå¹¶å°†å…¶ä¸é‡å ä¿¡æ¯ä¸€èµ·ä½¿ç”¨ï¼Œå¯ä»¥æ˜¾è‘—å‰Šå‡æœç´¢ç©ºé—´ï¼Œä½¿æ¢ç´¢å˜å¾—åˆ‡å®å¯è¡Œã€‚å…·ä½“æ¥è¯´ï¼Œåœ¨ synapse spark ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ 30 ç§’å†…ä¼˜åŒ–æ¯ä¸ªæŸ¥è¯¢ã€‚æˆ‘ä»¬æ ¹æ®æŸ¥è¯¢çš„å¤æ‚æ€§åŠ¨æ€é€‰æ‹© ğ‘˜ çš„å€¼æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼Œç”±äºå‰ªæï¼Œğ‘˜ = 4 è¶³ä»¥ä¸ºæ‰€æœ‰æŸ¥è¯¢æ‰¾åˆ°æœ€ä½³äº¤æ¢ä½ç½®ã€‚æˆ‘ä»¬åœ¨ç¬¬ 7. 4èŠ‚ä¸­è¯´æ˜ï¼Œå¦‚æœ ğ‘˜ å¤§äº 16ï¼ˆåœ¨æ²¡æœ‰å‰ªæçš„æƒ…å†µä¸‹éœ€è¦ï¼‰ï¼Œä¼˜åŒ–å™¨çš„é€Ÿåº¦ä¼šæ˜¾è‘—é™ä½ã€‚
