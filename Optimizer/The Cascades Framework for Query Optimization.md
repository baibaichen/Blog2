# The Cascades Framework for Query Optimization

> **Abstact**  This paper describes a new extensible query optimization framework that resolves many of the short-comings of the EXODUS and Volcano optimizer generators. In addition to extensibility, dynamic programming, and memorization based on and extended from the EXODUS and Volcano prototypes, this new optimizer provides (i) manipulation of operator arguments using rules or functions, ==(ii) operators that are both logical and physical for predicates etc., (iii) schema-specific rules for materialized views==,(iv) rules to insert ”enforcers” or ”glue operators,” (v) rule-specific guidance, permitting grouping of rules, (vi) basic facilities that will later permit parallel search, partially ordered cost measures, and dynamic plans, (vii) extensive tracing support, and (viii) a clean interface and implementation making full use of the abstraction mechanisms of C++. We describe and justify our design choices for each of these issues. The optimizer system described here is operational and will serve as the foundation for new query optimizers in Tandem’s NonStop SQL product and in Microsoft’s SQL Server product.

**摘要** 本文描述了一种新的可扩展查询优化框架，它解决了 EXODUS 和 Volcano 优化器生成器的许多缺点。除了从 EXODUS 和 Volcano 原型继承或者扩展而来的可扩展性、动态规划和 memorization 之外，这个新的优化器还提供 (i) 使用规则或函数处理运算符参数，==(ii) 谓词既是逻辑也是物理运算符，(iii) 物化视图有特定于 shema 的规则==，(iv) 插入**强制执行器**或**粘合运算符**的规则，(v) 特定于规则的指导，允许规则分组，(vi) 基本设施，将在以后允许并行搜索，部分有序的成本计算，和动态计划，(vii) 广泛支持跟踪，和( viii) 干净的接口和实现，充分利用 C++ 的抽象机制。本文将描述每个问题描述并证明我们的设计选择。此处描述的优化器系统是可落地的，并将作为 Tandem 的 NonStop SQL 和 Microsoft  SQL Server 中新查询优化器的基础。

## 1 Introduction

> Following our experiences with the EXODUS Optimizer Generator [GrD87], we built a new optimizer generator as part of the Volcano project [GrM93]. The main contributions of the EXODUS work were the optimizer generator architecture based on code generation from declarative rules, logical and physical algebra’s, the division of a query optimizer into modular components, and interface definitions for support functions to be provided by the **database implementor** (DBI), whereas the Volcano work combined improved extensibility with an efficient search engine based on dynamic programming and memorization. By using the Volcano Optimizer Generator in two applications, a object-oriented database systems [BMG93] and a scientific database system prototype [WoG93], we identified a number of flaws in its design. Overcoming these flaws is the goal of a completely new extensible optimizer developed in the Cascades project, a new project applying many of the lessons learned from the Volcano project on extensible query optimization, parallel query execution, and physical database design. Compared to the Volcano design and implementation, the new Cascades optimizer has the following advantages. In their entirety, they represent a substantial improvement over our own earlier work as well as other related work in functionality, ease-of-use, and robustness.
>
> - Abstract interface classes defining the DBI-optimizer interface and permitting DBI-defined subclass hierarchies
> - Rules as objects
> - Facilities for schemaand even query-specific rules
> - Simple rules requiring minimal DBI support
> - Rules with substitutes consisting of a complex expression
> - Rules that map an input pattern to a DBI-supplied function
> - Rules to place property enforcers such as sort operations
> - Operators that may be both logical and physical, e.g., predicates
> - Patterns that match an entire subtree, e.g., a predicate
> - Optimization tasks as data structures
> - Incremental enumeration of equivalent logical expressions
> - Guided or exhaustive search
> - Ordering of moves by promise
> - Rule-specific guidance
> - Incremental improvement of estimated logical properties
>
> The points in the list above and their effects will be discussed in this paper. While the system is operational, we have not performed any performance studies and the system is not fully tuned yet. Detailed analysis and focused improvement of the Cascades optimizer’s efficiency is left for further work.
>

根据我们使用 EXODUS 优化器生成器 [GrD87] 的经验，我们构建了一个新的优化器生成器，作为 Volcano 项目 [GrM93] 的一部分。EXODUS 工作的主要贡献是优化器生成器架构，它基于从声明性规则、逻辑和物理代数的代码生成；将查询优化器划分为模块化组件；以及由数据库实现者（DBI）提供的支持函数的接口定义，而 Volcano 的工作将改进的可扩展性与基于动态规划和 memorization 的高效搜索引擎结合起来。通过在两个应用程序中使用 Volcano Optimizer Generator，一个是面向对象的数据库系统 [BMG93]，另一个是科学数据库系统原型 [WoG93]，我们发现了其设计中的一些缺陷。克服这些缺陷是在 Cascades 项目中开发一个全新的可扩展优化器的目标，该新项目应用了从 Volcano 项目中学到的关于可扩展查询优化、并行查询执行和物理数据库设计的许多经验教训。与 Volcano 的设计和实现相比，新的 Cascades 优化器具有以下优点。总的来说，它们代表了对我们自己早期工作以及在功能、易用性和健壮性方面的其他相关工作的重大改进。

- 抽象接口类定义 DBI 优化器接口，并允许 DBI 定义子类层次结构
- 规则作为对象
- 特定于 Schema 甚至特定于查询规则的工具
- 需要最少 DBI 支持的简单规则
- 包含复杂表达式的替代规则
- 将输入模式对应到 DBI 提供的函数的规则
- 放置属性强制执行器的规则，例如排序操作
- 既可以是逻辑也可以是物理的运算符，例如谓词
- 匹配整个子树的模式，例如谓词
- **优化任务作为数据结构**
- 增量遍历等价逻辑表达式
- 引导或详尽的搜索
- 按 Promise 排序动作
- 特定规则的指南
- 估计逻辑属性的增量改进

本文将讨论上述列表中的要点及其影响。 虽然系统可以运行，但我们还没有进行任何性能研究，系统还没有完全调优。 Cascades 优化器效率的详细分析和重点改进留待进一步工作。

## 2  Optimization Algorithm and Tasks

> The optimization algorithm is broken into several parts, which we call ”tasks.” While each task could easily be implemented as a procedure, we chose to realize tasks as objects that, among other methods, have a ”perform” method defined for them. Task objects offer significantly more flexibility than procedure invocations, in particular with respect to search algorithm and search control. A task object exists for each task that has yet to be done; all such task objects are collected in a task structure. The task structure is currently realized as a last-in-first-out stack; however, other structures can easily be envisioned. In particular, task objects can be reordered very easily at any point, enabling very flexible mechanisms for heuristic guidance. Moreover, we plan on representing the task structure by a graph that captures dependencies or the topological ordering among tasks and permit efficient parallel search (using shared memory). However, in order to obtain a working system fast, the current implementation is restricted to a LIFO stack, and scheduling a task is very similar to invoking a function, with the exception that any work to be done after a sub-task completes must be scheduled as a separate task.
>
> Figure 1 shows the tasks that make up the optimizer’s search algorithm. Arrows indicate which type of task schedules (invokes) which other type; dashed arrows indicate where invocations pertain to inputs, i.e., subqueries or subplans. Brief pseudo-code for the tasks is also given in the appendix. The ”optimize()” procedure first copies the original query into the internal ”memo” structure and then triggers the entire optimization process with a task to optimize the class corresponding to the root node of the original query tree, which in turn triggers optimization of smaller and smaller subtrees.
>
> > - [ ] Figure 1 Optimization Tasks
>
> A task to optimize a group or an expression represents what was called an ”optimization goal” in the Volcano optimizer generator: it combines a ==group== or expression with a cost limit and with required and excluded physical properties. Performing such a task results either in a plan or a failure. **Optimizing a group means finding the best plan for any expression in the group and therefore applies rules to all expressions, whereas optimizing an expression starts with a single expression**. The former is realized by invoking the latter for each expression. The latter results in transitive rule applications and therefore, if the rule set is complete, finds the best plan within the starting expression’s group. The distinction between the two task types is made purely for pragmatic reasons. On the one hand, there must be a task to find the best plan for any expression in a group in order to initiate optimization of an entire query tree or a subtree after an implementation rule has been applied; on the other hand, there must be a task to optimize a single (new) expression after applying a transformation rule.
>
> The task to optimize a group also implements dynamic programming and **memorization**. Before initiating optimization of all a group’s expressions, it checks whether the same optimization goal has been pursued already; if so, it simply returns the plan found in the earlier search. Reusing plans derived earlier is the crucial aspect of dynamic programming and memorization. Exploring a group or an expression is an entirely new concept that has no equivalent in the Volcano optimizer generator. In the Volcano search strategy, a first phase applied all transformation rules to create all possible logical expressions for a query and all its subtrees. The second phase, which performed the actual optimization, navigated within that network of equivalence classes and expressions, applied implementation rules to obtain plans, and determined the best plan.
>
> In the Cascades optimizer, this separation into two phases is **abolished**, because it is not useful to derive all logically equivalent forms of all expressions, e.g., of a predicate. A group is explored using transformation rules only on demand, and it is explored only to create all members of the group that match a given pattern. Thus, exploring a group or an expression (the distinction between these two mirrors the distinction between optimizing a group or an expression) means deriving all logical expressions that match a given pattern. The pattern, which is part of the task definition, is a subtree of the **rule’s antecedent** or ”before”-pattern.
>
> As do optimization tasks, exploration tasks also avoid duplicate work. Before exploring a group’s expressions, the task to explore a group checks whether the same pattern has already been explored for the given group. If so, the task terminates immediately without spawning other tasks. Thus, the overall effort to expand logical expressions is also reduced by dynamic programming, i.e., retaining and reusing results of earlier search effort. The decision whether or not a pattern has already been explored is made using a ”pattern memory” initialized and administered by the DBI.
>
> In order to make this discussion more concrete, consider a join associativity rule. In Volcano, all equivalence classes are completely expanded to contain all equivalent logical expressions before the actual optimization phase begins. Thus, during the optimization phase, when a join operator matches the top join operator in the rule, all join expressions for the rule’s lower join are readily available so the rule can immediately applied with all possible bindings. In Cascades, these expressions are not immediately available and must be derived before the rule is applied. The exploration tasks provide this functionality; they are invoked not during a pre-optimization phase as in Volcano but on demand for a specific group and a specific pattern.
>
> One might ask which of the Volcano technique and the Cascades technique is more efficient and more effective. The Volcano technique generates all equivalent logical expressions exhaustively in the first phase. Even if the actual optimization phase uses a greedy search algorithm, this first phase in Volcano must still be exhaustive. In the Cascades technique, this represents the worst case. If there is no guidance indicating which rule might lead to expressions matching the given pattern, exhaustive enumeration of all equivalent logical expressions cannot be avoided. On the other hand, if there is some guidance, some of that effort can be avoided, and the Cascades search strategy seems superior. On the other hand, the same group might have to be explored multiple times for different patterns ; if so, redundant rule applications and derivations might occur. In order to avoid that, each expression in the ”memo” structure includes a bit map that indicates which transformation rules have already been applied to it and thus should not be re-applied. Thus, we believe that the Cascades search strategy is more efficient because it explores groups only for truly useful patterns. In the worst case, i.e., without any guidance, the efficiency of the Cascades search will equal that of the Volcano search strategy.
>
> On the other hand, if such guidance is incorrect, incorrect pruning of the search space may occur and the Cascades optimizer’s effectiveness might suffer. Thus, it is very important that such guidance be correct. We plan on using two techniques for guidance, which are not implemented yet. First, by inspecting the entire rule set, in particular the top operators of each rule’s antecedent (”before”-pattern) and consequent (”after”-pattern, substitute), we can identify which operators can be mapped to which other operators in a single rule application. By taking the transitive closure of this reachability relationship, we can exclude some rules from consideration. Note that this **transitive closure** can be computed when the optimizer is generated from the rule set, i.e., only once. Second, we plan on implementing mechanisms for guidance by the DBI.
>
> Applying a rule creates a new expression; notice that the new expression can be complex (consisting of multiple operators, as in a join associativity rule) and may be either a transformation rule (creating a new logical expression) or an implementation rule (creating a new physical expression or plan). In fact, since an operator can be both logical and physical, one rule may be both a transformation and an implementation rule. ==Correct rule application for such rules is guaranteed, although we expect such operators and rules to be exceptions rather than the norm==.
>
> Performing an ”apply rule” task is fairly complex. It may roughly be broken into four components. First, all bindings for the rule’s pattern are derived and iterated over one by one. Second, for each binding, the rule is used to create a new expression. <u>Note that for function rules, there may be multiple new expressions for each binding</u>. Third, the new expressions are integrated in the ”memo” structure. Within this process, exact replicas of expressions that already exist in ”memo” are identified and removed from further consideration. Fourth, each expression that is not a duplicate of an earlier one is optimized or explored with the same goal and context that triggered the current rule application. Let us discuss these four components in turn.
>
> Since each rule’s antecedent (”before”-pattern) may be complex, the Cascades optimizer employs a complex procedure to identify all possible bindings for a rule. This procedure is recursive, with each recursive invocation for each node in the pattern. Most of its complexity serves to obtain all possible bindings for a rule’s pattern. In fact, the procedure is realized as an iterator that produces the next feasible binding with each invocation. The state of this iteration is captured in the ”BINDING” class with one instance of that class for each node in the pattern. Once a binding is found, it is translated into a tree consisting of ”EXPR” nodes (note that this class is part of the DBI interface, whereas the optimizer’s internal data structures are not). **==This copy step represents some effort==**, but it isolates the optimizer from the DBI methods that may be invoked for this tree. For each binding, the rule’s condition function is invoked and qualifying bindings are then translated into the rule’s consequent (”after”-pattern, substitute). For some rules, this is very easy and entirely left to the optimizer. For other rules, the DBI specified a function to create the substitute, and this function is invoked repeatedly to create as many substitute as possible. In other words, this function may be an iterator producing multiple substitutes in consecutive invocations. Thus, the effort of extracting a binding from the ”memo” is leveraged for multiple transformations if possible.
>
> Each substitute expression is then integrated into the ”memo” structure. This process includes search for and detection of duplicates, i.e., expression that have been derived earlier in the optimization. This process is very similar to duplicate expression detection in both the EXODUS and Volcano optimizer generators. It is a recursive process that starts at the leaves of the substitute, which may be either query or plan tree leaves (i.e., scans) or leaf operators that denote the scope of a rewrite operation (as described as part of the DBI interface), and works upwards in the substitute towards the substitute’s root; this direction is required for correct duplicate detection. The search for duplicates is very fast as it employs a hash table using an operator and the groups of its inputs as keys.
>
> Finally, if a substitute’s root is a new expression, follow-on tasks may be initiated. If the substitute was created as part of an exploration, a task is created to explore the substitute for the same pattern. If the substitute was created as part of an optimization, the follow-on tasks depend on whether the rule was a transformation or an implementation rule, i.e., whether the substitute’s root operator is a logical or a physical operator. Note, again, that an operator can be both logical and physical; thus, a rule can be both a transformation or an implementation rule. In that case, both types of follow-on tasks are created. For a logical root operator, an optimization task is created to optimize the substitute, keeping the same optimization goal. For a physical root operator, a new task is scheduled to optimize the operator’s inputs and to calculated processing costs. The ”optimize inputs” task is different from all other tasks. While all other tasks schedule their follow-on tasks and then vanish, this sixth task type become active multiple times. In other words, it schedules a follow-on task, waits for its completion, resumes and schedules the next follow-on task, etc. The follow-on tasks are all of the same type, which is optimizing input groups for a suitable optimization goal. Thus, like the Volcano search strategy, the Cascades search engine guarantees that only those subtrees and interesting properties are optimized that could indeed participate in a query evaluation plan. Each time after an input has been optimized, the optimize inputs task obtains the best execution cost derived, and derives a new cost limit for optimizing the next input. ==Thus, pruning is as tight as possible==.


优化算法分成几个部分，我们称之为**任务**。虽然可以很容易地用过程来实现每个任务，但我们选择将任务实现为对象，在所有方法中，我们定义了一个 `perform` 方法。任务对象提供比过程调用更大的灵活性，特别是在搜索算法和搜索控制方面。每个尚未完成的任务都存在一个任务对象；所有这些任务对象都收集在一个任务结构中。任务结构目前实现为后进先出的堆栈；然而，可以很容易地设想其他结构。特别是，可以在任何时候非常容易地重新排序任务对象，从而实现非常灵活的启发式引导机制。此外，我们计划用一个图来表示任务结构，该图捕获任务之间的依赖关系或拓扑顺序，并允许高效的并行搜索(使用共享内存)。然而，为了快速获得一个可工作系统，目前的实现仅限于后进先出堆栈，调度任务与调用函数非常相似，不同的是，子任务完成后要做的任何工作必须作为一个单独的任务来调度。

图 1 显示了构成优化器搜索算法的任务。箭头指示哪种类型的任务调度（调用）哪种其他类型的任务； 虚线箭头表示调用与输入相关的位置，即子查询或子计划。附录中还给出了这些任务的简短伪代码。 `optimize()` 过程首先将原始查询复制到内部的 **memo** 结构中，然后用一个任务触发整个优化过程，优化原始查询树根节点对应的类，从而触发整个优化过程，而这个任务又会触发对越来越小的子树的优化。

> - [ ] Figure 1 Optimization Tasks

优化组或表达式的任务代表了 Volcano 优化器生成器中所谓的**优化目标**：它将组或表达式与成本限制以及所需和排除的物理属性相结合。执行这样的任务要么生成执行计划，要么失败。**优化组意味着为组中的任何表达式找到最佳方案，从而将规则应用于所有表达式，而优化表达式从单个表达式开始**。前者通过为每个表达式调用后者来实现。后者导致应用规则，因此，如果规则集是完整的，就会在初始表达式的组中找到最佳计划。这两种任务类型之间的区别纯粹是出于实用主义的原因。一方面，在应用了实现规则后，必须有一个任务来为组中的任何表达式找到最佳的计划，以便对整个查询树或子树进行优化；另一方面，在应用转换规则后，必须有一个任务来优化单个（新）表达式。

优化组的任务还实现了动态规划和 **memorization**。在开始优化一个组的所有表达式之前，它会检查是否已经追求了相同的**==优化目标==**； 如果是，它只返回在早期搜索中找到的计划。重用早期得到的计划是动态规划和 **memorization** 的关键特点。探索组或表达式是一个全新的概念，在 Volcano 优化器生成器中没有类似的东西。在 Volcano 搜索策略中，第一阶段应用所有转换规则，为查询及其所有子树创建所有可能的逻辑表达式。第二阶段执行实际优化，在等价类和表达式网络中导航，应用**实现规则**获得执行计划，并确定最佳计划。

在 Cascades 优化器中，这种分为两个阶段的分离被取消了，因为导出所有表达式（例如谓词）所有的逻辑等价形式并不有用。只在需要时使用转换规则来探索组，并且探索该组时，创建组中匹配给定模式的所有成员。因此，探索组或表达式（这两者之间的区别和优化组或表达式之间的区别一样）意味着转换<u>与给定模式匹配的所有逻辑表达式</u>。<u>==模式是任务定义的一部分，是规则的 antecedent 或 before-pattern 的子树==</u>。

与优化任务一样，探索任务也避免重复工作。在探索组的表达式之前，探索组的任务检查是否已经为给定的组探索了相同的模式。 如果是这样，任务将立即终止而不产生其他任务。因此，动态规划也减少了扩展逻辑表达式的总体工作，即保留和重用早期搜索工作的结果。模式是否已被探索的信息，保存在由 DBI 初始化和管理的**模式内存**中。

为了使这个讨论更具体，考虑一个 Join 结合规则。在 Volcano 中，在实际优化阶段开始之前，所有等价类都被完全扩展以包含所有等价的逻辑表达式。因此，在优化阶段，当 Join 运算符匹配规则中的顶部的 Join 运算符时，该规则下 Join 的所有 Join 表达式都可用，因此该规则可以立即应用于所有可能的绑定。在 Cascades 中，这些表达式不是立即可用的，必须在应用规则之前导出。**探索任务**提供此功能；它们不像在 Volcano 中那样在预优化阶段被调用，而是根据特定组和特定模式按需调用。

有人可能会问 Volcano 和 Cascades 哪个技术更高效、更有效。Volcano 在第一阶段详尽地生成所有等价的逻辑表达式。即使实际的优化阶段使用了贪心搜索算法，Volcano 中的第一阶段仍然必须是详尽的。在 Cascades 技术中，这代表了最坏的情况。==如果没有指示哪条规则可能导致匹配给定模式的表达式==，则无法避免详尽列举所有等价逻辑表达式。另一方面，如果有一些指导，则可以避免一些努力，而 Cascades 搜索策略似乎更胜一筹。另一方面，对于不同的模式，可能必须多次探索同一组；如果是这样，可能会出现冗余的规则应用和推导。为了避免这种情况，**memo** 结构中的每个表达式都包含一个位图，表示哪些转换规则已经应用到该表达式，因此不应重新应用。因此，我们相信 Cascades 搜索策略更有效，因为它仅针对真正有用的模式探索组。最坏的情况下，即没有任何指导，Cascades 的搜索效率将等于 Volcano 的搜索策略。

另一方面，如果这样的指导不正确，搜索空间的修剪可能会发生错误，Cascades 的有效性可能会受到影响。因此，正确指导非常重要。我们计划使用两种技术（还没做）来实现指导。首先，通过检查整个规则集，特别是每个规则 before-pattern 和 after-pattern（substitute）的顶层运算符，我们可以确定在一次规则应用中，那些运算符可以转换为那些运算符。通过采用这种可达性关系的**==传递闭包==**，我们可以排除一些规则。请注意，当从规则集生成优化器时，可以计算此**==传递闭包==**，即只此一次。其次，我们计划实施 DBI 的指导机制。

应用规则会创建一个新的表达式； 注意，新表达式可能很复杂（由多个运算符组成，如在 Join 结合规则中），并且可能是转换规则（创建新的逻辑表达式）或实现规则（创建新的物理表达式或计划）。 事实上，由于运算符既可以是逻辑的，也可以是物理的，所以一条规则可能既是转换规则又是实现规则。==虽然我们希望此类运算符和规则是例外而不是规范，但可以保证此类规则的正确应用==。

**应用规则**的任务相当复杂。大致分为四个部分。首先，规则模式的所有绑定都被逐个派生和迭代。其次，对于每个绑定，规则用于创建一个新表达式。注意，对于**<u>==函数规则==</u>**，每个绑定可能有多个新表达式。第三，集成新表达式到 memo 结构中。在此过程中，表达式的精确副本如果已经存在于 memo 中，将被识别出来，从进一步的考虑中移除。第四，每一个不与之前表达式重复的，都被优化或探索，其优化目标和优化上下文与当前触发的规则相同。让我们依次讨论这四个组成部分.

由于每个规则的 before-pattern 可能很复杂，所以 Cascades 优化器使用一个复杂的过程来标识规则的所有可能绑定。这个过程是递归的，模式中的每个节点都有递归调用。它的大部分复杂性是为了获取规则模式的所有可能绑定。事实上，该过程被实现为一个迭代器，它在每次调用时生成下一个可行的绑定。该迭代的状态在 `BINDING` 类中被捕获，模式中的每个节点都有该类的一个实例。一旦找到绑定，它就被转换成由 `EXPR` 节点组成的树（注意，这个类是 DBI 接口的一部分，优化器的内部数据结构则不是 DBI 的一部分）。**==此复制步骤需要做一些工作==**，但它将优化器与可能为该树调用的 DBI 方法隔离开来。对于每个绑定，调用规则的条件函数，然后将符合条件的绑定转换为规则的结果（after-pattern, substitute）。对于某些规则，这很简单，完全由优化器来完成。对于其他规则，DBI 指定了一个函数来创建替换，这个函数被反复调用以创建尽可能多的替换。换句话说，这个函数可能是一个迭代器，在连续调用中产生多个替换。因此，如果可能的话，从 memo 中提取绑定的工作将用于多个转换。

然后将每个替换表达式集成到 **memo** 结构中。这个过程包括搜索和检测重复项（即在优化之前导出的表达式）。这个过程与 EXODUS 和 Volcano 优化器生成器中的重复表达式检测非常相似。它是一个递归过程，从替代的叶子开始，可以是查询或计划树的叶子（即扫描）或表示重写操作范围的叶子运算符（如 DBI 接口的一部分所述）， 并在替代中朝着根向上遍历； 正确的重复检测需要这个方向。 重复项的搜索非常快，因为它使用一个哈希表，使用运算符和它的输入组作为键。

最后，如果替换的根是一个新表达式，则可能启动后续任务。如果替代是作为探索的一部分创建的，则会创建一个任务来探索相同模式的替代。如果替代是作为优化的一部分创建的，则后续任务取决于是转换规则还是实现规则，即替代的根运算符是逻辑运算符还是物理运算符。再次注意，运算符既可以是逻辑的，也可以是物理的；因此，规则既可以是转换规则，也可以是实现规则。在这种情况下，将创建两种类型的后续任务。如果根是逻辑运算符，创建优化任务来优化替代，保持相同的优化目标。如果根是物理运算符，将创建一项新任务来优化运算符的输入并计算处理成本。**优化输入**任务不同于所有其他任务。其他类型的任务安排完他们的后续任务后消失，而这第六种任务类型会多次激活。换句话说，它调度后续任务，等待其完成，恢复并调度下一个后续任务，等等。后续任务都是相同的类型，即为实现合适的优化目标而优化输入组。因此，与 Volcano 搜索策略一样，Cascades 搜索引擎保证只优化那些确实可以参与查询执行计划的子树和有意义的属性。每次优化输入后，优化输入任务都会算出最佳执行成本，并为优化下一个输入得出新的成本限制。==所以，修剪是尽可能紧的==。

## 3 Data Abstraction and the User Interface

> Developing the Cascades optimizer system required pursuing three different activities in rapid **alternation**. First, designing the interface between database implementor and optimizer had to focus on minimal, functional, and clean abstractions. Second, implementing a prototype optimizer as our own DBI was an exercise in exploiting the interface as effectively as possible. Third, design and implementation of an efficient search strategy was based on lessons learned during the EXODUS and Volcano projects, combined with the requirements set forth by a workshop of academic and industrial query optimization researchers and by the first user group of this software. Each of these three activities had different goals and required a different mind-set; in our internal discussions, we constantly alternated among these perspectives in order to design and develop a truly extensible and useful tool. In this section, we describe the data structuring decisions made for the interface between database implementor and the optimizer.
>
> Users of the EXODUS and Volcano optimizer generator generators made it very clear that the interface of these system could bear improvement. Feedback from users of the Volcano optimizer generator matches our own analysis [BMG93]; therefore, we focused on (i) clean abstractions for support functions in order to enable an optimizer generator to create them from specification, (ii) rule mechanisms that permit the DBI to choose rules or functions to manipulate operator arguments (such as predicates), and (iii) more concise and complete interface specifications, both in the code and in the written documentation. Following these guidelines, we designed the following interface.
>
> Each of the classes that make up the interface between the Cascades optimizer and the DBI is designed to become the root of a subclass hierarchy. Thus, creation of new objects of one of these classes is associated with another class. For example, creation a new ”guidance” structure is associated with a ”rule” object. The rule object can be of some DBI-defined subclass of the interface class ”RULE,” and the newly created guidance structure can be of any DBI-defined subclass of the interface class ”GUIDANCE.” The optimizer relies only on the method defined in this interface; the DBI is free to add additional methods when defining subclasses.
>

开发 Cascades 优化器系统需要在快速变化中进行三种不同的活动。首先，数据库和优化器之间的接口必须是最小、实用和干净的抽象。其次，将原型优化器实现为我们自己的 DBI（数据库实现），这是一种尽可能有效地利用接口的练习。第三，高效搜索策略的设计和实现是基于 EXODUS 和 Volcano 项目期间的经验教训，并结合学术和工业查询优化研究人员，以及该软件的第一个用户组提出的要求。这三种活动都有不同的目标，需要不同的思维模式；在我们的内部讨论中，为了设计和开发一个真正可扩展和有用的工具，我们不断地在这些视角之间转换。在本节中，我们将描述为数据库实现和优化器之间的接口所做的数据结构决策。

EXODUS 和 Volcano 优化器生成器的用户非常清楚地表明，这些系统的接口可以得到改进。Volcano 优化器生成器用户的反馈与我们自己的分析 [BMG93] 相符；因此，我们专注于 (i) 支持函数的清晰抽象，以便优化器生成器能够根据规范创建它们，(ii) 允许 DBI 选择规则或函数来处理运算符参数（例如谓词）的规则机制， (iii) 代码和书面文档中更简洁和完整的接口规范。遵循这些准则，我们设计了以下接口。

组成 Cascades 优化器和 DBI 之间接口的每个类都被设计成类层次结构中的根。这样，创建这些类的新对象将与另一个类相关联。例如，创建新的**指导**结构与**规则**对象相关联。规则对象可以是 `RULE` 接口的某个 DBI 定义的子类，而新创建的指导结构可以是 `GUIDANCE` 接口的某个 DBI 定义的子类。优化器仅依赖于接口中定义的方法；DBI 在定义子类时可以自由添加额外的方法。

### 3.1 Operators and Their Arguments

> Central to any database query optimizer are the sets of operators supported in the query language and in the query evaluation engine. Notice that these two sets are different; we call them logical and physical operators [Gra93]. While previous extensible operators required that these two sets be disjunct, we have abandoned this requirement. The ”class OP-ARG” in the Cascades optimizer interface includes both logical and physical operators. For each operator, one method called ”is-logical” indicates whether or not an operator is a logical operator, while a second method called ”is-physical” indicates whether or not an operator is a physical operator. In fact, it is possible that an operator is neither logical or physical; such an operator might be useful if the optimization is organized as an expansion grammar including ”non-terminals” like the Starburst optimizer [Loh88]. On the other hand, a DBI who wishes to do so can easily retain a strict separation of logical and physical operators, e.g., by defining subclasses with suitable definitions for the methods ”is-logical” and ”is-physical” and by defining all operators as subclasses of these two classes.
>
> The definition of operators includes their arguments. Thus, no separate mechanisms are required or provided for ”argument transfer” as in EXODUS and Volcano. Notice, however, that there are two crucial facilities that permits and encourage modeling predicates etc., which had been modeled as operator arguments in all our prototypes constructed in the EXODUS and Volcano frameworks, as primary operators in the logical and physical algebra’s. First, an operator can be both logical and physical, which is natural for single-record predicates, called ”sargable” in System R [SAC79]. Second, specific predicate transformations, e.g., splitting from a complex predicate those components that can be pushed through a join, which are most easily and efficiently implemented in a DBI function rather than as rules to be interpreted by the optimizer’s search engine, can easily be realized in rules that invoke a DBI-supplied to map an expression to substitute expressions (one or more). Thus, after the EXODUS and the Volcano work has been repeatedly criticized that predicate manipulation has been very cumbersome, the Cascades optimizer offers much improved facilities.
>
> The optimizer’s design does not include assumptions about the logical and physical algebra’s to be optimized; therefore, no query or plan operators are built into the optimizer. For use in rules, however, there are two special operators, called ”LEAF-OP” and ”TREE-OP.” The leaf operator can be used as leaf in any rule; during matching, it matches any subtree. Before a rule is applied, an expression is extracted from the search memory that matches the rule’s pattern; where the rule’s pattern has leaves, the extracted expression also has leaf operators that refer (via an array index) to equivalence classes in the search memory. The tree operator is like the leaf operator except that the extracted expression contains an entire expression, independent of its size or complexity, down to the leaf operators in the logical algebra. This operator is particularly useful in connection with function rules, which are described below.
>
> Beyond the methods ”is-logical” and ”is-physical,” all operators must provide a method ”optcutoff”. Given a set of moves during an optimization task, this method determines how many of those will be pursued, obviously the most promising ones. By default, all possible moves will be pursued, because exhaustive search guarantees that the optimal plan will be found. There is also a small set of methods that must be provided only for those operators that have been declared logical. For pattern matching and for finding duplicate expressions, methods for matching and hashing are required. Methods for finding and improving logical properties are used to determine an original set of properties (e.g., the schema) and then to improve it when alternative expressions have been found (e.g., more bounds on selectivity or the output size). Finally, for exploration tasks, an operator may be called upon to initialize a pattern memory and to decide how many moves to pursue during an exploration task. 
>
> Similarly, there are some methods for physical operators. Obviously, there is a method to determine an operator’s (physical) output properties, i.e., **properties of the representation**. Moreover, there are three methods that compute and inspect costs. The first of these calculates the local cost of an algorithm, without any regard to the costs of its inputs. The second one combines the costs and physical properties of an algorithm’s inputs into the cost of an entire subplan. The third of these methods verifies, between optimizing two inputs of an algorithm, that the cost limit has not been exceeded yet, and computes a new cost limit to be used when optimizing the next input. Finally, just as the last method maps an expression’s cost limit to a cost limit for one of its inputs, there is a method that maps the optimization goal for an expression to an optimization goal for one of its inputs, i.e., a cost limit and required and excluded physical properties, called ”input-reqd-prop.” Let us discuss properties and their methods next.
>

所有数据库查询优化器的核心都是查询语言和查询计算引擎中支持的运算符集。注意，这两个集合是不同的；我们称它们为逻辑和物理运算符 [Gra93]。虽然以前的可扩展运算符要求这两个集合是分离的，但我们已经放弃了这个要求。Cascades 优化器接口中 `class OP-ARG` 包括逻辑和物理运算符。对于每个运算符，一个称为 `is-logical` 的方法表示是否为逻辑运算符，而另一个称为 `is-physical` 的方法表示是否为物理运算符。**事实上，运算符可能既不是逻辑的也不是物理的**；如果优化<u>被设计成包含**非终结符**的扩展语法</u>，比如 Starburst 优化器 [Loh88]，那么这样的运算符可能会很有用。另一方面，希望这样做的 DBI 可以轻松地保持逻辑运算符和物理运算符的严格分离，例如，为方法 `is-logical` 和 `is-physical` 定义合适的子类，并将所有运算符定义这两个类的子类。

运算符的定义包括它们的参数。因此，不需要像在 EXODUS 和 Volcano 中那样提供单独的机制来进行**参数传输**。但是请注意，有两个关键工具允许和鼓励**将谓词建模为逻辑和物理代数中的主要运算符**，而在 EXODUS 和 Volcano 框架中构建的所有原型中，谓词都被建模为运算符参数。首先，运算符可以是逻辑和物理的，这对于单记录谓词来说很自然，在 System R [SAC79] 中称为 **sargable**。其次，在调用 DBI 提供的将表达式映射到替代表达式（一个或多个）的规则中，可以很容易地实现特定的谓词转换，例如，从复杂的谓词中分离出那些可以下推到 Join 的部分谓词，它们在 DBI 函数中可以轻松有效地实现，而不是作为优化器搜索引擎解释的规则。因此，在 EXODUS 和 Volcano 的工作被反复批评谓词操作非常繁琐之后，Cascades 优化器提供了很多改进的设施。

优化器的设计不包括关于要优化的逻辑和物理代数的假设；因此，优化器中没有内置查询或计划操作符。但是，为了在规则中使用，有两个特殊的操作符，称为 **LEAF-OP** 和 **TREE-OP**。叶运算符可以在任何规则中用作叶节点；在匹配过程中，它匹配任何子树。在应用规则之前，从搜索内存中提取与规则模式匹配的表达式；当规则的模式有叶子时，提取的表达式也有叶子运算符，这些运算符（通过数组索引）引用搜索内存中的等价类。树运算符与叶运算符类似，不同之处在于，所提取的表达式包含完整的表达式，与表达式的大小或复杂度无关，直至逻辑代数中的叶运算符。这个运算符在与函数规则相关时特别有用，如后面所述。

除了 `is-logical` 和 `is-physical` 方法之外，所有运算符都必须提供一个 `opt-cutoff` 方法。在优化任务中给定一组移动，该方法确定将进行多少移动，显然是最有希望的移动。默认情况下，将执行所有可能的移动，因为穷举搜索保证会找到最优方案。还有一小部分方法，那些声明为逻辑运算符的类必须提供。对于模式匹配和寻找重复表达式，需要 `match` 和 `hash` 方法。查找和改进逻辑属性的方法用于确定一组原始属性（例如 Schema），然后在找到替代表达式时对其进行改进（例如，选择性或输出大小的更多限制）。最后，对于探索任务，可以要求运算符初始化模式内存，并决定在探索任务期间进行多少移动。

同样，物理运算符也有一些方法。显然，有一种方法可以确定运算的（物理）输出属性，即**表示的属性**。此外，还有三种计算和检查成本的方法。第一种计算算法的局部成本，而不考虑其输入的成本。第二种将算法输入的成本和物理属性组合到整个子计划的成本中。第三种在优化算法的两个输入之间验证是否超过成本限制，并计算新的成本限制，以便在优化下一个输入时使用。最后，就像最后一种方法将表达式的成本限制映射到其输入之一的成本限制一样，还有一种方法可以将表达式的优化目标映射到其输入之一的优化目标，即成本限制和必需和排除的物理属性，称为 `input-reqd-prop`。接下来让我们讨论属性及其方法。



### 3.2 Logical and Physical Properties, Costs

> The interface to the interface for anticipated execution costs, the `class COST`, is very simple, since instances of costs are created and returned by methods associated with other classes, e.g., operators. Beyond destruction and printing, the only method for costs is a comparison method. Similarly, the only method for the encapsulation of logical properties, the `class SYNTH-LOG-PROP`, is a hash function that permits faster retrieval of duplicate expressions. Since even this function does not apply to physical expressions, the encapsulation for physical properties, the `class SYNTH-PHYS-PROP`, has no methods at all. The class for required physical properties, the `class REQD-PHYS-PROP`, has only one method associated with it, which determines whether a synthesized physical property instance covers the required physical properties. If one set of properties is more specific than another, e.g., one indicates a result sorted on attributes ”A, B, C” and the one requires sort order on ”A, B” only, the comparison method returns the value ”MORE.” The default implementation of this method returns the value ”UNDEFINED.”

用于预期执行成本的接口，即 `class COST`，非常简单，因为成本的实例是由与其他类（如运算符）关联的方法创建和返回。除了销毁和打印，`COST` 的唯一方法是比较。类似地，封装逻辑属性的 `class SYNTH-LOG-PROP` 的唯一方法是一个哈希函数，允许更快地检索重复表达式。因为哈希函数也不适用于物理表达式，所以物理属性的封装 `class SYNTH-PHYS-PROP`，根本没有方法。所需物理属性的类 `class REQD-PHYS-PROP`，只有一个方法与之关联，该方法确定合成的物理属性实例是否涵盖所需的物理属性。如果一组属性比另一组更具体，例如，表示按列 “A、B、C” 排序的结果一组物理属性，和只要求按 “A、B” 排序的另一组物理属性，比较方法返回值 “MORE”。此方法的默认实现返回 “UNDEFINED”。

### 3.3 Expression Trees

> In order to communicate expressions between the DBI and the optimizer, e.g., as queries, as plans, or in rules, another abstract data type is part of the interface, call the `class EXPR`. Each instance of this class is a node in a tree, consisting of an operator and to pointers to input nodes. Obviously, the number of children in any expression node must be equal to the arity function of the node’s operator. Methods on an expression node, beyond constructor, destructor, and printing, include methods to extract the operator or one of the inputs as well as a matching method, which recursively traverses two expression trees and invokes the matching method for each node’s operator.
>

为了在 DBI 和优化器之间传递表达式，例如作为查询、作为计划或在规则中，另一种抽象数据类型是接口的一部分，称为 `class EXPR`。此类的每个实例都是树中的一个节点，由运算符和指向输入节点的指针组成。 显然，表达式节点中子节点的数量必须等于节点运算符的元数。表达式节点上的方法，除了构造函数、析构函数和打印之外，还包括提取运算符或其中一个输入的方法，以及一个 match 方法，该方法递归遍历两个表达式树，并为每个节点的运算符调用匹配方法。

### 3.4 Search Guidance

> In addition to pattern, cost limits, and required and excluded physical properties, rule application can also controlled by heuristics represented by instances of the `class GUIDANCE`. **Its purpose is to transfer optimization heuristics from one rule application to the next**. Notice that costs and properties pertain to the expressions being manipulated and to the intermediate result those expressions will product when a query plan is executed; the guidance class captures knowledge about the search process and heuristics for future search activities. For example, some rules such as commutativity rules are to applied only once; for those, a simple guidance structure and a rule class are provided as part of the DBI interface, called ”ONCE-GUIDANCE” and ”ONCE-RULE.”
>
> Some researchers have advocated to divide a query optimizer’s rule set into ”modules” that can be invoked one at a time, e.g., Mitchell et al. [MDZ93]. Guidance structures can easily facilitate this design: a guidance structure indicates which module is to be chosen, and each rule checks this indication in its promise (or condition) function and then creates suitable indications when creating guidance structures for its newly created expressions and their inputs.

除了模式、成本限制以及所需和排除的物理属性之外，规则应用还可以由 `class GUIDANCE` 实例表示的启发式方法进行控制。它的目的是将优化启发式从一个规则应用转移到下一个规则应用。注意，成本和属性属于被操作的表达式，以及在执行查询计划时，这些表达式将产生的中间结果；指导类捕获关于搜索过程和未来搜索活动的启发式知识。例如，一些规则，如交换规则只能用一次；对于它们，DBI 接口提供了一个简单的指导结构和一个规则类，称为 `ONCE-GUIDANCE` 和 `ONCE-RULE`。

一些研究人员主张将查询优化器的规则集划分为每次只能调用一个的**模块**，例如，Mitchell 等人[MDZ93]。指导结构可以很容易地促进这种设计：指导结构指示要选择哪个模块，每个规则在其承诺（或条件）函数中检查该指示，然后在为其新创建的表达式及其输入创建指导结构时创建合适的指示 .

### 3.5 Pattern Memory
> In addition to the search guidance, exploration effort can be restricted by use of the pattern memory. The purpose of the pattern memory is to prevent that the same group is explored unnecessarily, e.g., twice for the same pattern. There is one instance of a pattern memory associated with each group. Before a group is explored for a pattern, the pattern memory is permitted to add the pattern to itself and is asked to determine whether or not exploration should take place. In the most simple search, in which exploration for any pattern is performed by exhaustive application of transformation rules, the pattern memory needs to contain only a Boolean, i.e., a memory whether or not the group has been explored previously. More sophisticated pattern memories would store each pattern.
>
> Obviously, the pattern memory interacts with the exploration promise function. For the most simple promise function that always admits exhaustive search, the simple pattern memory above is suitable. It is left to the DBI to design pattern memory and promise functions most suitable to the algebra to be optimized.
>
> Beyond checking whether a given pattern already exists in the memory, and saving it to detect a second exploration with the same pattern, the most complex method for pattern memories is to merge two pattern memories into one. This method is required when two groups of equivalent expressions are detected to be actually one, i.e., when a transformed expression already occurs in a different group in the search memory.

除了搜索指导之外，还可以通过使用模式内存来限制探索。模式内存的目的是防止对同一组进行不必要的探索，例如，对同一模式进行两次探索。每个组都有一个模式内存实例。在为 group 探索模式之前，模式内存被允许将模式添加到自身，并被要求确定是否应该进行探索。在最简单的搜索中，对任何模式的探索都是通过彻底应用转换规则来执行，模式内存只需要包含一个布尔值，即该 Group 之前是否已经探索过。更复杂的模式内存将存储每个模式。

显然，模式内存与探索 promise 函数相互作用。对于最简单的 promise 函数，总是允许穷举搜索，上面的简单模式内存是合适的。对于要优化的代数，留给 DBI 去设计最合适的模式内和 promise 函数。

除了检查给定的模式是否已经存在于内存中，并将其保存以检测对相同模式的第二次探索之外，模式内存最复杂的方法是将两个模式内存合并为一个。当检测到两组等价的表达式实际上是一个时，即当一个转换后的表达式已经在搜索内存中不同的 Group 中出现时，就需要使用此方法。

### 3.6 Rules

> Next to operators, the other important class of objects in the Cascades optimizer are rules. Notice that rules are objects; thus, new ones can be created at run-time, they can be printed, etc. While other rule-based optimizers, in particular the EXODUS and Volcano optimizer generators, divide logical and physical operators as well as (logical) transformation and (physical) implementation rules into disjoint sets, the Cascades optimizer does not distinguish between those rules, other than by invoking the is-logical and is-physical methods on newly created expressions. All rules are instances of the ”class RULE,” which provides for rule name, an antecedent (the ”before” pattern), and a consequent (the substitute). Pattern and substitute are represented as expression trees, which were discussed above.
>
> In their simplest case, rules do not contain more than that; <u>==whenever the pattern is found or can be created with exploration tasks==</u>, the substitute expression is included in the search memory. Both a rule’s pattern and substitute can be arbitrarily complex. In the EXODUS and Volcano optimizer generators, an implementation rule’s substitute could not consist of more than a single implementation operator; in the Cascades design, this restriction has been removed. The remaining restriction is that all but the substitute’s top operator must be logical operators. For example, it is possible to transform a (logical) join operator into a (physical) nested loops operator with a (logical) selection on its inner input, thus, detaching the selection predicate from the join algorithm and pushing it into the inner input tree.
>
> For more sophisticated rules, two types of condition functions are supported. All of them consider not only the rule but also the current optimization goal, i.e., cost limit and required and excluded physical properties. First, before exploration starts, ”promise” functions informs the optimizer how useful the rule might be. There is one promise function for optimization tasks and one for exploration tasks. For unguided exhaustive search, all promise functions should return the value 1.0. A value of 0 or less will prevent the optimizer from further work for the current rule and expression. The default promise function returns 0 if a specific physical property is required, 2 if the substitute is an implementation algorithm, and 1 otherwise. If the cutoff methods associated with the operators choose exhaustive search (see above), the return value of the promise function will not change the quality of the final query evaluation plan, although it may affect the order in which plans are found, pruning effectiveness, and therefore the time an optimization takes.
>
> Since the promise functions are invoked before exploration of subgroups, i.e., before entire expression trees corresponding to a rule’s pattern have been explored and extracted from the search memory, **a ”condition” function** checks whether a rule is truly applicable after exploration is complete and a complete set of operators corresponding to the pattern in the rule is available. Whereas the promise functions return a real value that expresses grades of promise, the condition function returns a Boolean to indicate whether or not the rule is applicable.
>
> In addition to promise and condition functions, a small set of methods is associated with rules. Of course, there are constructor, destructor, and print methods, as well as method to extract the pattern, the substitute, the rule’s name, and its arity (the pattern’s number of leaf operators). The `rule-type` method indicates whether a rule is a simple rule (as described so far) or a function rule (to be described shortly). The `top-match` method determines whether or not an operator in the search memory matches the top operator in the rule’s pattern; this method is the only built-in check before an promise function is invoked. The method `opt-cases` indicates how often a physical expression is to be optimized with different physical properties. <u>In all but a few cases, this will be one</u>; one of the few exception is a merge-join algorithm with two equality clauses (say `R.A==S.A and R.B==S.B`) that should be optimized for two sort orders (sorted on ”A, B” and on ”B, A”). By default, this method returns 1. The remaining methods all create new guidance structures to be used when optimizing a newly created expression and its inputs. There are two methods each for optimization and for exploration, and two each for the new expression and for its inputs, called `opt-guidance`, `expl-guidance`, `input-opt-guidance`, and `input-expl-guidance`. By default, all of them return ”NULL,” i.e., no specific guidance.
>
> If a rule’s substitute consists of only a leaf operator, the rule is a reduction rule. If a reduction rule is applicable, two groups in the search memory will be merged. On the other hand, if a rule’s pattern consists of only a leaf operator, the rule is an expansion rule that is always applicable. The Cascades optimizer must rely on the DBI to design appropriate promise and condition functions to avoid useless transformations. Nonetheless, there is an important class of situations in which expansion rules are useful, namely the insertion of physical operators that enforce or guarantee desired physical properties. Such rules may also be called enforcer rules. Consider the inputs to a merge-join’s inputs, which must be sorted. An enforcer rule may insert a sort operation, the rule’s promise and condition functions must permit this rule only of sort order is required, and the sort operator’s `input-reqd-prop` method must set excluded properties to avoid consideration of plans that produce their output in the desired sort order as input to the sort operator.
>
> In some situations, it is easier to write a function that directly transforms an expression than to design and control a rule set for the same transformation. For example, dividing a complex join predicate into clauses that apply to left, right, and both inputs is a deterministic process best implemented by a single function. For those cases, the Cascades optimizer supports a second class of rules, called the `class FUNCTION-RULE`. Once an expression is extracted that corresponds to the rule’s pattern, an iterator method is invoked repeatedly to create all substitutes for the expression. Note that the extracted expression can be arbitrarily deep and complex if the tree operator (see above) is employed in the rule’s pattern. Thus, tree operators and function rules permit the DBI to write just about any transformation. In the extreme case, a set of function rules could perform all query transformations, although that would defeat some of the Cascades framework’s purpose.

除了运算符之外，Cascades 优化器中另一个重要的对象类是规则。注意规则是对象；因此，可以在运行时创建新的，可以打印等。 而其他基于规则的优化器，特别是 EXODUS 和 Volcano 优化器生成器，划分逻辑和物理运算符以及（逻辑）转换和（物理 ) 实现规则到不相交的集合中，Cascades 优化器不区分这些规则，除了在新创建的表达式上调用 `is-logical` 和 `is-physical` 方法。 所有规则都是 `“class RULE` 的实例，它提供规则名称、before-pattern 和结果（替代）。模式和替代被表示为表达式树。[上面已经讨论过](# 3.3 Expression Trees)。

在最简单的情况下，规则不包含更多内容；<u>==每当找到匹配模式的表达式或可以通过探索任务创建探索任务时==</u>，替换表达式就会包含在搜索内存中。规则的模式表达式和替换表达式可以任意复杂。在 EXODUS 和 Volcano 优化器生成器中，实现规则的替代表达式不能包含一个以上的实现运算符； 在 Cascades 设计中，此限制已被删除。剩下的限制是，除了替换的顶层运算符之外，所有的运算符都必须是逻辑运算符。例如，可以将（逻辑）Join 运算符转换为（物理）嵌套循环运算符，在其内部输入是（逻辑）选择，从而将选择谓词从连接算法中分离出来，并将其推入内部输入树。

对于更复杂的规则，支持两种类型的条件函数。它们不仅考虑了规则，还考虑了当前的优化目标，即成本限制、所需和排除的物理性质。**首先**，在探索开始之前，`promise` 函数会告知优化器该规则可能有多有用。优化任务和探索任务各有一个 `promise` 函数。对于无指导的穷举搜索，所有 `promise` 函数都应返回值 1.0。0 或更小的值将阻止优化器对当前规则和表达式进行进一步的工作。如果需要特定的物理属性，则默认 `promise` 函数返回 0，如果替换表达式是一个实现算法，则返回 2，否则返回 1。如果与运算符关联的截止方法选择穷举搜索（见上文），`promise` 函数的返回值不会改变最终查询执行计划的质量，尽管它可能会影响找到计划的顺序、剪枝效果、因此影响优化所需的时间。

由于在探索子组之前调用了 `promise` 函数，即，在探索并从搜索内存中提取与规则模式对应的整个表达式树之前，**条件函数**在探索完成后检查规则是否真正适用，并且可以使用与规则中的模式对应的完整操作符集。`promise` 函数返回一个表示 **promise** 等级的真实值，而条件函数返回一个布尔值来指示规则是否适用。

除了`promise` 和条件函数之外，还有一小组方法与规则相关联。当然，有构造函数、析构函数和打印方法，以及提取模式、替代表达式、规则名称和元数（模式的叶运算符数量）的方法。`rule-type` 方法表示示规则是简单规则（如前面所述）还是函数规则（稍后将描述）。`top-match` 方法确定搜索内存中的运算符是否与规则模式中的顶部运算符匹配；此方法是调用 `promise` 函数之前唯一的内置检查。方法 `opt-cases` 表示物理表达式根据不同物理特性进行优化的频率。默认情况下，此方法返回 1。大多数情况都是这样；少数例外之一是 merge-join 算法，如果它有两个相等子句，例如：`R.A==S.A and R.B==S.B`，该算法应该针对两种排序顺序进行优化（分别按 “A、B” 和 “B、A” 排序）。剩下的方法都创建了新的指导结构，用于优化新创建的表达式及其输入。优化和探索分别有一种方法，新表达式及其输入也分别有一种方法，称为 `opt-guidance`、`expl-guidance`、`input-opt-guidance` 和 `input-expl-guidance`。它们默认都返回 `NULL`，即没有具体的指导。

如果规则的替代表达式仅包含叶运算符，则该规则是约简规则。如果约简规则可用，则将合并搜索内存中的两个 group。另一方面，如果规则的模式表达式仅由叶运算符组成，则该规则是始终适用的扩展规则。Cascades 优化器必须依赖 DBI 来设计适当的 `promise` 和条件函数，以避免无用的转换。尽管如此，在一些重要的情况下，扩展规则是有用的，即插入强制或保证所需物理属性的物理运算符。这样的规则也可以称为强制执行器规则。考虑 merge-join 的输入，必须有序。强制执行器规则可以插入一个排序操作，规则的 `promise` 和条件函数必须允许这个规则只需要排序顺序，并且排序操作的`input-reqd-prop`方法必须设置排除属性，避免生成这样的计划：以所需的排序顺序生成的输出，并作为排序运算符的输入。

在某些情况下，**编写直接转换表达式**的函数比设计和控制相同功能的规则转换集更容易。例如，将复杂的 Join 谓词划分为分别适用于左右表达式和两个输入的子句是一个确定性过程，最好由单个函数实现。对于这些情况，Cascades优化器支持第二类规则，称为 `class FUNCTION-RULE`。一旦提取出与规则模式对应的表达式，就会重复调用迭代器方法以创建表达式的所有替代项。注意，如果在规则模式中使用树运算符（见上文），则提取的表达式可以是任意深度和复杂的。因此，树运算符和函数规则允许 DBI 编写任何转换。在极端情况下，一组函数规则可以执行所有查询转换，尽管这会违背 Cascades 框架的某些目的。

## 4 Future Work

> Of course, there is a lot of work that should be done to make the Cascades optimizer more useful and complete. First, the optimizer has not yet gone through a thorough evaluation and tuning phase. Second, building additional optimizers based on this framework will undoubtedly show many weaknesses not yet apparent. Third, one or more generators that produce Cascades specifications from higher-level data model and algebra descriptions would be very useful. Fourth, we already know of a number of desirable improvements for the search strategy and its implementation.
>
> The Cascades optimizer was designed to be reasonably fast, although extensibility was a more important design goal. Among the artifacts of separating the optimizer framework and the DBI’s specification of operators, cost functions, etc. are extensive use of virtual methods, a very large number of references between structures, and very frequent object allocation and deallocation. While unavoidable, there probably is room for improvement, in particular if one is willing to give up the strong separation that permits modifications of DBI code without recompiling Cascades code. Before this ”de-modularization” step is taken, however, a strong argument should be made based on a measurement study that this would indeed improve an optimizer’s performance.

当然，要使 Cascades 优化器更有用、更完整，还需要做很多工作。首先，优化器还没有经过彻底的评估和调优阶段。其次，基于这个框架构建额外的优化器无疑会显示出许多尚不明显的弱点。第三，从高级数据模型和代数描述生成 Cascades 规范的一个或多个生成器将非常有用。第四，我们已经知道搜索策略及其实现的一些理想的改进。

尽管可扩展性是更重要的设计目标，但 Cascades 优化器被设计得相当快，在分离优化器框架和 DBI 运算符、成本函数等规范的组件中，有大量的虚方法的使用、结构之间的大量引用以及非常频繁的对象分配和回收。虽然不可避免，但可能还有改进的余地，特别是如果人们愿意放弃允许修改 DBI 代码而无需重新编译 Cascades 代码的强分离。然而，在采取这种**去模块化**步骤之前，应该基于测量研究提出一个强有力的论点，即这确实会提高优化器的性能。


## 5    Summary and Conclusions
> Beyond a better and more robust implementation than found in the EXODUS and Volcano optimizer generators, the Cascades optimizer offers a number of advantages, without giving up modularity, extensibility, dynamic programming, and memorization explored in those earlier prototypes. First, predicates and other item operations can conveniently modeled as part of the query and plan algebra. Operators that are both logical and physical; thus, it is easy to specify operators that may appear both in the optimizer input (the query) an din its output (the plan). Function rules and the tree operator permit direct manipulation of even complex trees of item operations using DBI-supplied functions. Second, enforcers such as sorting are normal operators in all ways; in particular, they are inserted into a plan based on explicit rules. In Volcano, they were special operators that did not appear in any rule. Third, both exploration (enumeration of equivalent logical expressions) and optimization (mapping a logical to a physical expression) can be guided and controlled by the DBI. Together with the more robust implementation as required for industrial deployment, we believe that the Cascades optimizer represents a substantial improvement over earlier extensible database query optimizers.

除了比 EXODUS 和 Volcano 优化器生成器更好、更健壮的实现之外，Cascades 优化器还提供了许多优点，而且没有放弃那些早期原型中探索的模块化、可扩展性、动态规划和 memorization  功能。首先，谓词和其他 item 运算可以方便地建模为查询和计划代数的一部分。运算符可以使逻辑的，也可以是物理的；因此，很容易指定可能出现在优化器输入（查询）和输出（计划）中的运算符。函数规则和树运算符允许使用 DBI 提供的函数直接操作甚至是复杂的项操作树。其次，排序之类的强制执行器在各方面都是正常的运算符；特别是基于明确的规则，将它们插入到计划中。在 Volcano 中，他们是特殊的运算符，没有出现在任何规则中。第三，探索（枚举等价逻辑表达式）和优化（将逻辑表达式映射到物理表达式）都可以由 DBI 引导和控制。再加上工业部署所需的更健壮的实现，我们相信 Cascades 优化器代表了对早期可扩展数据库查询优化器的重大改进。

## 6    Acknowledgments
> The query processing group at Tandem has been very helpful in forcing me to address the hard problems unresolved in the EXODUS and Volcano optimizer generators and in finding effective and usable solutions. David Maier has been **a great sounding board for ideas** during the design and development of the Cascades optimizer.

Tandem 的查询处理小组在迫使我解决 EXODUS 和 Volcano 优化器生成器中未解决的难题以及寻找有效和可用的解决方案方面提供了很大的帮助。 在 Cascades 优化器的设计和开发过程中，David Maier  一直是一个**很好的意见领袖**。