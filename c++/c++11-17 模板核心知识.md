# C++11-17 模板核心知识

# 零 —— 导语

##  为什么要整理 cpp11-17TemplateTutorial

缘起于看folly源码时有好多模板相关的语法，遇到不会的需要经常查，给阅读带来极大的困难。且市面上关于模板的资料较少、较旧、内容较为零散不系统。其中，内容零散不系统对于我来说是一个最大的问题，因为我C++模板没有写过多少，对于某一个特性或者用法，不知道其在模板的知识体系框架中处在什么位置、解决了什么问题，**想要查相关的语法都不知道怎么查、查的关键词是什么。** 所以，我根据后面列出的三个参考资料，整理了模板的核心知识点，内容不求涉及到所有方面，但求梳理出主要脉络，同时融入C++11-17模板的新特性。

## 最终目的

- 梳理出模板的主要知识脉络，看模板相关代码时不会再一直纠结语法相关的问题。即使查语法也知道这个语法属于什么方面的内容，最大限度节省查询时间。
- 熟悉掌握C++11-17中模板的新特性，它们什么时候用、具体解决了什么问题。
- 不会关注模板原理、元编程方面的内容。

## 相关内容

1. 函数模板
2. 类模板
3. 非类型模板参数 Nontype Template Parameters
4. 可变参数模板 Variadic Template
5. 理解模板参数推导规则
6. 理解auto推导规则
7. 模板参数 按值传递 vs 按引用传递
8. enable_if<>与SFINAE
9. 理解decltype与decltype(auto)
10. 区分万能引用(universal references)和右值引用
11. 编写泛型库需要的基本技术
12. 模板的模板参数 Template Template Parameters
13. 名称查找与ADL
14. 解析模板之依赖型模板名称 Dependent Names of Templates(.template/->template/::template)
15. 解析模板之依赖型类型名称(Dependent Names of Types)与typename
16. 注入类与当前实例化（Injected Class Names And Current Instantiations）

## 参考资料

内容基本来自下面的三本书，就不一一在后面的文章中写了。

### [C++ Templates (第2版 英文版)](https://link.zhihu.com/?target=https%3A//book.douban.com/subject/30226708/)

这是那本[C++Templates中文版](https://link.zhihu.com/?target=https%3A//book.douban.com/subject/2378124/)的第二版，补充了很多C++11/C++14/C++17模板相关新特性。想系统学模板相关内容的强烈推荐这本书，**注意是第二版**。我的大部分内容和代码都是参考的这本书。

![img](https://pic3.zhimg.com/80/v2-5d2bbc3554fbf285a881dc29c4e66442_720w.webp)

### [Effective Modern C++](https://link.zhihu.com/?target=https%3A//book.douban.com/subject/25923597/)

参考了这本书模板参数和auto推导规则相关的内容。

![img](https://pic1.zhimg.com/80/v2-ee2edfeebdc1ed6a60ab5e96941a1564_720w.webp)

### [C++17 - The Complete Guide](https://link.zhihu.com/?target=https%3A//book.douban.com/subject/34928844/)

> https://github.com/MeouSker77/Cpp17
>
> https://github.com/CnTransGroup/Cpp17TheCompleteGuideChinese

参考了这本书C++17相关的内容。这本书关于C++17新特性的内容很系统也很全，是个比较好的参考书。

![img](https://pic1.zhimg.com/80/v2-3b277cc6b3316741fc5f8d37a5cd94b8_720w.webp)

# （一）—— 函数模板

## 定义函数模板

```cpp
template<typename T>
T max(T a,T b) {
  return b < a ? a : b;
}
```

## 使用函数模板

```cpp
std::cout << max(7,42) << std::endl;

std::cout << max(1.1,2.2) << std::endl;

std::cout << max("math","mathematics") << std::endl;
```

模板不是被编译成可以处理任何类型的单个函数。相反，编译器会针对每一个使用该模板的类型生成对应的函数。例如，`max(7,42)`的调用在语义上相当于调用了：

```cpp
int max(int a,int b) {
  return b < a ? a : b;
}
```

`double`、`string` 同理。

**将模板参数替换成具体参数类型的过程叫做 `instantiation`，这个过程会产生一个 `instance of template`。**



![img](https://pic2.zhimg.com/80/v2-c571a2ffe8b09adb5ecf00ea52efc8f9_720w.webp)



## 两阶段翻译 Two-Phase Translation

如果某一特定参数类型不支持模板内的操作，那么编译阶段会报错，例如：

```cpp
std::complex<float> c1,c2;        //不支持 max中的 < 操作，编译阶段会报错
...
max(c1,c2);
```

模板会分成两个阶段进行”编译“： 

1. 在不进行模板 `instantiation` 的 `definition time`阶段，此时会忽略模板参数，检查如下方面： 语法错误，包括缺失分号。  使用未定义参数。 如果 `static assertion` 不依赖模板参数，会检查是否通过 `static assertion.` 
2. 在 `instantiation` 阶段，会再次检查模板里所有代码的正确性，尤其是那些依赖模板参数的部分。

例如：

```cpp
template<typename T>
void foo(T t) {
  undeclared();                                   // first-phase compile-time error if undeclared() unknown
  undeclared(t);       														// second-phase compile-time error if undeclared(T) unknown
  static_assert(sizeof(int) > 10,"int too small");// first-phase compile-time error
  static_assert(sizeof(T) > 10, "T too small");   // second-phase compile-time error
}
```

![img](https://pic4.zhimg.com/80/v2-a6cd646221606850937d964048e2febf_720w.webp)



### 模板的编译和链接问题

大多数人会按照如下方式组织非模板代码： 将类或者其他类型声明放在头文件(.hpp、.H、.h、.hh、.hxx)中。将函数定义等放到一个**单独的编译单元**文件中(.cpp、.C、.c、.cc、.cxx)。

但是这种组织方式在包含模板的代码中却行不通，例如： 头文件：

```cpp
// myfirst.hpp
#ifndef MYFIRST_HPP
#define MYFIRST_HPP
// declaration of template
template<typename T>
void printTypeof (T const&);
#endif // MYFIRST_HPP
```

定义函数模板的文件：

```cpp
// myfirst.cpp
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"
// implementation/definition of template
template<typename T>
void printTypeof (T const& x) {
  std::cout << typeid(x).name() << '\n';
}
```

在另一个文件中使用该模板：

```cpp
// myfirstmain.cpp
#include "myfirst.hpp"
// use of the template
int main() {
  double ice = 3.0;
  printTypeof(ice); // call function template for type double
}
```

在 c/c++ 中，当编译阶段发现一个符号 `printTypeof` 没有定义只有声明时，编译器会假设它的定义在其他文件中，所以编译器会留一个**坑**给链接器，让它去填充真正的符号地址。

但是上面说过，模板是比较特殊的，需要在编译阶段进行 `instantiation`，即需要进行模板参数类型推断，实例化模板，当然也就需要知道函数的定义。但是由于上面两个 cpp 文件都是**单独的编译单元文件**，所以当编译器编译 `myfirstmain.cpp` 时，它没有找到模板的定义，自然也就没有 `instantiation`。

解决办法就是我们把模板的声明和定义都放在一个头文件。大家可以看一下自己环境下的 vector 等 STL 源文件，就是把类的声明和定义都放在了一个文件中。

## 多模板参数

```cpp
template<typename T1, typename T2>
T1 max (T1 a, T2 b) {
    return b < a ? a : b;
}
...
auto m = max(4, 7.2);       // 注意：返回类型是第一个模板参数T1 的类型
```

但是问题正如注释中说的，max的返回值类型总是T1。如果我们调用`max(42, 66.66)`，返回值则是66。

一般有三个方法解决这个问题：

- 引入额外模板参数作为返回值类型
- 让编译器自己找出返回值类型
- 将返回值声明为两个模板参数的公共类型，比如int和float，公共类型就是float

### 引入额外模板参数作为返回值类型

在函数模板的参数类型推导过程中，一般我们不用显式指定模板参数类型。但是当模板参数不能根据传递的参数推导出来时，我们就需要显式的指定模板参数类型。

```cpp
template<typename T1, typename T2, typename RT>
RT max(T1 a, T2 b);
```

RT是不能根据函数的参数列表推导出来的，所以我们需要显式的指定：

```cpp
max<int, double, double>(4, 7.2);
```

或者我们改变模板参数列表顺序，这种情况只需显式的指定一个参数类型即可：

```cpp
template<typename RT typename T1, typename T2>      //RT变为第一个模板参数
RT max(T1 a, T2 b);   
...
max<double>(4, 7.2);
```

### 让编译器自己找出返回值类型

在C++11中，我们可以利用auto和trailing return type来让编译器找出返回值类型：

```cpp
template <typename T1, typename T2>
auto max(T1 a, T2 b) -> decltype(b < a ? a : b) {
  return b < a ? a : b;
}
```

decltype后面的文章会讲到，这里只需知道它可以获取到表达式的类型。

我们可以写的更简单点：

```cpp
template <typename T1, typename T2>
auto max(T1 a, T2 b) -> decltype(true ? a : b) {      // true ? a : b
  return b < a ? a : b;
}
```

关于?:返回值规则可以参考这个：[Conditional Operator: ? :](https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2012/e4213hs1(v%3Dvs.110)%3Fredirectedfrom%3DMSDN)

看到`true ? a : b`不要奇怪为什么是true，**这里的重点不是计算返回值，而是得到返回值类型。**

在C++14中，我们可以省略trailing return type：

```cpp
template<typename T1, typename T2>
auto max (T1 a, T2 b) {
    return b < a ? a : b;
}
```

### 将返回值声明为两个模板参数的公共类型

c++11新特性`std::common_type`可以产生几个不同类型的共同类型，其实核心意思跟上面说的差不多：

```cpp
template <typename T1, typename T2>
typename std::common_type<T1, T2>::type max(T1 a, T2 b) {
  return b < a ? a : b;
}
```

在c++14中，可以更简单的写：

```cpp
template <typename T1, typename T2>
std::common_type_t<T1, T2> max(T1 a, T2 b) {     
  return b < a ? a : b;
}
```

这里使用`_t`后缀让我们不用写`typename`和`::type`。类似的还有_v，这个在c++14的`type traits`里很常见。

![img](https://pic4.zhimg.com/80/v2-c0d5db646e202fc885eedcad10c8f0e7_720w.webp)

## 默认模板参数

这个很像函数的默认参数，直接看例子：

```cpp
template <typename T1, typename T2, typename RT = std::common_type_t<T1, T2>>
RT max(T1 a, T2 b) {
  return b < a ? a : b;
}

auto a = max(4, 7.2);
auto b = max<double,int,long double>(7.2, 4);
```

正如第二个用法，如果我们想显示的指明RT的类型，必须显示的指出全部三个参数类型。**但是与函数默认参数不同的是，我们可以将默认参数放到第一个位置：**

```cpp
template <typename RT = long, typename T1, typename T2> 
RT max(T1 a, T2 b) {
  return b < a ? a : b;
}

int i;
long l;
…
max(i, l);                     // 返回值类型是long (RT 的默认值)
max<int>(4, 42);      //返回int，因为其被显式指定
```

## 重载函数模板

这个跟普通函数重载也类似：

```cpp
// maximum of two int values:
int max(int a, int b) { 
  return b < a ? a : b; 
}

// maximum of two values of any type:
template <typename T> 
T max(T a, T b) { 
  return b < a ? a : b; 
}

int main() {
  max(7, 42);         // calls the nontemplate for two ints
  max(7.0, 42.0);     // calls max<double> (by argument deduction)
  max('a', 'b');      // calls max<char> (by argument deduction)
  max<>(7, 42);       // calls max<int> (by argument deduction)
  max<double>(7, 42); // calls max<double> (no argument deduction)
  max('a', 42.7);     // calls the nontemplate for two ints
}
```

这里需要解释下最后一个`max('a', 42.7)`。**因为在模板参数类型推导过程中不允许类型自动转换，但是调用普通函数是允许的，所以这个会调用非模板函数。**

**ps. 由于函数模板重载，所以函数模板并不像类模板一样可以进行偏特化。**

还有两点关于重载的基本原则需要了解一下:

### 重载时最好不要随便改变模板参数个数，最好可以显示的指定模板参数类型

下面是段有问题的代码：

```cpp
// maximum of two values of any type (call-by-reference)
template <typename T> T const &max(T const &a, T const &b) {
  return b < a ? a : b;
}

// maximum of two C-strings (call-by-value)
char const *max(char const *a, char const *b) {
  return std::strcmp(b, a) < 0 ? a : b;
}

// maximum of three values of any type (call-by-reference)
template <typename T> T const &max(T const &a, T const &b, T const &c) {
  return max(max(a, b), c);           // error if max(a,b) uses call-by-value
}

int main() {
  auto m1 = max(7, 42, 68);         // OK

  char const *s1 = "frederic";
  char const *s2 = "anica";
  char const *s3 = "lucas";
  auto m2 = max(s1, s2, s3);         // run-time ERROR
}
```

问题出现在`return max (max(a,b), c);`，因为`char const *max(char const *a, char const *b)`的参数是按值传递，`max(a,b)`会产生一个指向已经销毁的栈帧地址，这会导致未定义行为。

### 确保所有被重载的函数模板在使用时已经被声明定义

```cpp
// maximum of two values of any type:
template <typename T> 
T max(T a, T b) {
  std::cout << "max<T>()\n";
  return b < a ? a : b;
}

// maximum of three values of any type:
template <typename T> 
T max(T a, T b, T c) {
  return max(max(a, b), c); 
}

// maximum of two int values:
int max(int a, int b) {
  std::cout << "max(int,int) \n";
  return b < a ? a : b;
}

int main() {
  max(47, 11, 33);    // max<T>()
}
```

这点很好理解。

# （二）—— 类模板

## 类模板声明、实现与使用

声明：

```cpp
template <typename T>
class Stack {
private:
  std::vector<T> elems; // elements
public:
  void push(T const &elem); // push element
  void pop();               // pop element
  T const &top() const;     // return top element
  bool empty() const {      // return whether the stack is empty
    return elems.empty();
  }
};
```

实现：

```cpp
template <typename T>
void Stack<T>::push(T const &elem) {
  elems.push_back(elem); // append copy of passed elem
}

template <typename T>
void Stack<T>::pop() {
  assert(!elems.empty());
  elems.pop_back(); // remove last element
}

template <typename T>
T const &Stack<T>::top() const {
  assert(!elems.empty());
  return elems.back(); // return copy of last element
}
```

使用：

```cpp
int main() {
  Stack<int> intStack;            // stack of ints
  Stack<std::string> stringStack; // stack of strings

  // manipulate int stack
  intStack.push(7);
  std::cout << intStack.top() << '\n';

  // manipulate string stack
  stringStack.push("hello");
  std::cout << stringStack.top() << '\n';
  stringStack.pop();
}
```

有两点需要注意

- 在类声明内的构造函数、拷贝构造函数、析构函数、赋值等用到类名字的地方，可以将`Stack<T>`简写为`Stack`，例如：

```cpp
template<typename T>
class Stack {
  ...
  Stack (Stack const&);                           // copy constructor
  Stack& operator= (Stack const&);      // assignment operator
...
};
```

但是在类外，还是需要`Stack<T>`:

```cpp
template<typename T>
bool operator== (Stack<T> const& lhs, Stack<T> const& rhs);
```

- 不可以将类模板声明或定义在函数或者块作用域内。通常类模板只能定义在 global/namespace 作用域，或者是其它类的声明里面。

## Class Instantiation

instantiation 的概念在函数模板中说过。在类模板中，类模板函数只有在被调用时才会被`instantiate`。在上面的例子中，`push()`和`top()`都会被`Stack<int>`和`Stack<std::string>`所`instantiate`，但是`pop()`只被`Stack<std::string>`所`instantiate`。

![img](https://pic4.zhimg.com/80/v2-a917bc061fdb0aaf29d1eefcb244b25f_720w.webp)

## 使用类模板的部分成员函数

我们为 Stack 新提供`printOn()`函数，这需要`elem`支持`<<`操作：

```cpp
template<typename T>
class Stack {
...
    void printOn (std::ostream& strm) const {
        for (T const& elem : elems) {
             strm << elem << ' ';           // call << for each element
         }
    }
};
```

根据上一小节关于类模板的`instantiation`，只有使用到该函数时才会进行该函数的`instantiation`。假如我们的模板参数是元素不支持`<<`的`std::pair< int, int>`，那么仍然可以使用类模板的其他函数，只有调用`printOn`的时候才会报错：

```cpp
Stack<std::pair< int, int>> ps; // note: std::pair<> has no operator<<
defined
ps.push({4, 5}); // OK
ps.push({6, 7}); // OK
std::cout << ps.top().first << ’\n’; // OK
std::cout << ps.top().second << ’\n’; // OK

ps.printOn(std::cout); // ERROR: operator<< not supported for element type
```

### Concept

这就引出了一个问题，我们如何知道一个类模板和它的模板函数需要哪些操作？

在 c++11 中，我们有`static_assert`:

```cpp
template<typename T>
class C
{
    static_assert(std::is_default_constructible<T>::value, "Class C requires default-constructible elements");
...
};
```

假如没有 static_assert，提供的模板参数不满足`std::is_default_constructible`，代码也编译不过。但是编译器产出的错误信息会很长，包含整个模板`instantiation`的信息——从开始`instantiation`直到引发错误的地方，让人很难找出错误的真正原因。

所以使用 static_assert 是一个办法。但是 static_assert 适用于做简单的判断，实际场景中我们的场景会更加复杂，例如判断模板参数是否具有某个特定的成员函数，或者要求它们支持互相比较，这种情况下使用 concept 就比较合适。

concept 是 c++20 中用来表明模板库限制条件的一个特性，在后面会单独说明 concept，这里为了文章篇幅先暂时只说一下为什么要有 concept.

## 友元

**首先需要明确一点：友元虽然看起来好像是该类的一个成员，但是友元不属于这个类。这里友元指的是友元函数和友元类。这点对于理解下面各种语法规则至关重要。**

### 方式一

```cpp
template<typename T>
class Stack {
  ...
  void printOn(std::ostream &strm) const {
    for (T const &elem : elems) {
      strm << elem << ' '; // call << for each element
    }
  }

  template <typename U>
  friend std::ostream &operator<<(std::ostream &, Stack<U> const &);
};

template <typename T>
std::ostream &operator<<(std::ostream &strm, Stack<T> const &s) {
  s.printOn(strm);
  return strm;
}


int main() {
  Stack<std::string> s;
  s.push("hello");
  s.push("world");

  std::cout << s;

  return 0;
}
```

这里在类里声明的友元函数使用的是与类模板不同的模板参数`<template typename U>`，是因为友元函数的模板参数与类模板的模板参数不互相影响，**这可以理解为我们创建了一个新的函数模板。**

再举一个友元类的例子：

```cpp
template<typename T>
class foo {
  template<typename U>
  friend class bar;
};
```

**这里也使用的是不同的模板参数。也就是：`bar<char>`、`bar<int>`、`bar<float>`和其他任何类型的 bar 都是`foo<char>`的友元。**

### 方式二

```cpp
template<typename T>
class Stack;
template<typename T>
std::ostream& operator<< (std::ostream&, Stack<T> const&);

template<typename T>
class Stack {
  ...
  friend std::ostream& operator<< <T> (std::ostream&, Stack<T> const&);
};
```

这里提前声明了 Stack与`operator<<`，并且在类模板中，`operator<<`后面使用了`<T>`，没有使用新的模板参数。**与第一种方式对比，这里创建了一个特例化的非成员函数模板作为友元 (注意这个友元函数的声明，是没有`<T>`的 )。**

方式一中第二个友元类的例子用本方式写是：

```cpp
template<typename T>
class bar;

template<typename T>
struct foo {
  friend class bar<T>;
};
```

**对比的，这里只有`bar<char>`是`foo<char>`的友元类。**

关于类模板友元规则有很多，知道有哪几大类规则即可（Friend Classes of Class Templates、Friend Functions of Class Templates、Friend Templates），用到的时候再查也来得及。可以参考：《C++ Templates Second Edition》12.5 小节。 （关注公众号：红宸笑。回复：电子书 获取 pdf）

## 类模板的全特化

与函数模板类似，但是要注意的是，如果你想要全特化一个类模板，你必须全特化这个类模板的所有成员函数。

```cpp
template <>
class Stack<std::string> {
private:
  std::deque<std::string> elems; // elements
public:
  void push(std::string const &); // push element
  void pop();                     // pop element
  std::string const &top() const; // return top element
  bool empty() const {            // return whether the stack is empty
    return elems.empty();
  }
};
void Stack<std::string>::push(std::string const &elem) {
  elems.push_back(elem); // append copy of passed elem
}

void Stack<std::string>::pop() {
  assert(!elems.empty());
  elems.pop_back(); // remove last element
}

std::string const &Stack<std::string>::top() const {
  assert(!elems.empty());
  return elems.back(); // return copy of last element
}
```

在类声明的开始处，需要使用`template<>`并且表明类模板的全特化参数类型：

```cpp
template<>
class Stack<std::string> {
...
};
```

在成员函数中，需要将`T`替换成特化的参数类型：

```cpp
void Stack<std::string>::push (std::string const& elem) {
  elems.push_back(elem); // append copy of passed elem
}
```

## 类模板的偏特化

类模板可以针对某一些特性场景进行部分特化，比如我们针对模板参数是指针进行偏特化：

```cpp
// partial specialization of class Stack<> for pointers:
template <typename T>
class Stack<T *> {
private:
  std::vector<T *> elems; // elements
public:
  void push(T *);      // push element
  T *pop();            // pop element
  T *top() const;      // return top element
  bool empty() const { // return whether the stack is empty
    return elems.empty();
  }
};

template <typename T>
void Stack<T *>::push(T *elem) {
  elems.push_back(elem); // append copy of passed elem
}

template <typename T>
T *Stack<T *>::pop() {
  assert(!elems.empty());
  T *p = elems.back();
  elems.pop_back(); // remove last element
  return p;         // and return it (unlike in the general case)
}

template <typename T>
T *Stack<T *>::top() const {
  assert(!elems.empty());
  return elems.back(); // return copy of last element
}
```

注意类声明与全特化的不同：

```cpp
template<typename T>
class Stack<T*> {
};
```

使用：

```cpp
Stack<int*> ptrStack; // stack of pointers (special implementation)
ptrStack.push(new int{42});
```

### 多模板参数的偏特化

与函数模板重载类似，比较好理解。

原模板：

```cpp
template<typename T1, typename T2>
class MyClass {
...
};
```

重载：

```cpp
// partial specialization: both template parameters have same type
template<typename T>
class MyClass<T,T> {
...
};

// partial specialization: second type is int
template<typename T>
class MyClass<T,int> {
...
};

// partial specialization: both template parameters are pointer types
template<typename T1, typename T2>
class MyClass<T1*,T2*> {
...
};
```

使用：

```cpp
MyClass<int,float> mif;          // uses MyClass<T1,T2>
MyClass<float,float> mff;     // uses MyClass<T,T>
MyClass<float,int> mfi;         // uses MyClass<T,int>
MyClass<int*,float*> mp;       // uses MyClass<T1*,T2*>
```

同样也会有重载冲突：

```cpp
MyClass<int,int> m; // ERROR: matches MyClass<T,T> and MyClass<T,int>
MyClass<int*,int*> m; // ERROR: matches MyClass<T,T> and MyClass<T1*,T2*>
```

![img](https://pic3.zhimg.com/80/v2-91bfd90391bdac27daeaddd5a8c8b46a_720w.webp)

## 默认模板参数

也与函数默认参数类似。比如我们为`Stack<>`增加一个默认参数，代表管理 Stack 元素的容器类型：

```cpp
template <typename T, typename Cont = std::vector<T>>
class Stack {
private:
  Cont elems; // elements
public:
  void push(T const &elem); // push element
  void pop();               // pop element
  T const &top() const;     // return top element
  bool empty() const {      // return whether the stack is empty
    return elems.empty();
  }
};

template <typename T, typename Cont>
void Stack<T, Cont>::push(T const &elem) {
  elems.push_back(elem); // append copy of passed elem
}

template <typename T, typename Cont>
void Stack<T, Cont>::pop() {
  assert(!elems.empty());
  elems.pop_back(); // remove last element
}

template <typename T, typename Cont>
T const &Stack<T, Cont>::top() const {
  assert(!elems.empty());
  return elems.back(); // return copy of last element
}
```

注意定义成员函数的模板参数变成了 2 个：

```cpp
template<typename T, typename Cont>
void Stack<T,Cont>::push (T const& elem) {
  elems.push_back(elem); // append copy of passed elem
}
```

使用：

```cpp
// stack of ints:
Stack<int> intStack;

// stack of doubles using a std::deque<> to manage the elements
Stack<double,std::deque<double>> dblStack;
```

## Type Aliases

### new name for complete type

两种方式：typedef、using(c++11)

- typedef

```cpp
typedef Stack<int> IntStack;
void foo (IntStack const& s);
IntStack istack[10];
```

- using

```cpp
using IntStack = Stack<int>;
void foo (IntStack const& s);
IntStack istack[10];
```

### alias template

**using 比 typedef 有一个很大的优势是可以定义 alias template：**

```cpp
template <typename T>
using DequeStack = Stack<T, std::deque<T>>; // stack of strings

int main() {
  DequeStack<int> ds;

  return 0;
}
```

再强调一下，不可以将类模板声明或定义在函数或者块作用域内。通常类模板只能定义在 global/namespace 作用域，或者是其它类的声明里面。

在之前函数模板文章中介绍过的`std::common_type_t`，实际上就是一个别名：

```cpp
template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
```

### Alias Templates for Member Types

- typedef:

```cpp
struct C {
  typedef ... iterator;
  ...
};
```

- using:

```cpp
struct MyType {
  using iterator = ...;
  ...
};
```

使用：

```cpp
template<typename T>
using MyTypeIterator = typename MyType<T>::iterator;       // typename必须有
MyTypeIterator<int> pos;
```

### 关键字 typename

上面的注释说明了：`typename MyType<T>::iterator`里的`typename`是必须的，因为这里的 typename 代表后面紧跟的是一个定义在类内的类型，否则，`iterator`会被当成一个静态变量或者枚举：

```cpp
template <typename T> class B {
public:
  static int x;                 // 类内的静态变量
  using iterator = ...;     // 类内定义的类型
};

template <typename T>
int B<T>::x = 20;

int main() {

  std::cout << B<int>::x;     // 20

  return 0;
}
```

### Using or Typedef

个人倾向使用 using :

- using 使用`=`，更符合看代码的习惯、更清晰：

```cpp
typedef void (*FP)(int, const std::string&);       // typedef

using FP = void (*)(int, const std::string&);       // using
```

- 上面提到的，using 定义`alias template`更方便。

![img](https://pic4.zhimg.com/80/v2-4961c2d32d49952e19f345a0b6a3593f_720w.webp)

## 类模板的参数推导 Class Template Argument Deduction

或许你会觉得每次使用模板时都需要显示的指明模板参数类型会多此一举，如果类模板能像`auto`一样自动推导模板类型就好了。在 C++17 中，这一想法变成了可能：如果构造函数能够推导出所有的模板参数，那么我们就不需要显示的指明模板参数类型。

```cpp
Stack<int> intStack1; // stack of strings
Stack<int> intStack2 = intStack1; // OK in all versions
Stack intStack3 = intStack1; // OK since C++17
```

添加能推断出类模型类型的构造函数：

```cpp
template<typename T>
class Stack {
  private:
      std::vector<T> elems; // elements
  public:
      Stack () = default;       //
      Stack (T elem) : elems({std::move(elem)}) {}
...
};
```

使用：

```cpp
Stack intStack = 80;      // Stack<int> deduced since C++17
```

之所以添加`Stack () = default;`是为了`Stack<int> s;`这种默认构造不报错。

### Deduction Guides

我们可以使用`Deduction Guides`来提供额外的模板参数推导规则，或者修正已有的模板参数推断规则。

```cpp
Stack(char const*) -> Stack<std::string>;

Stack stringStack{"bottom"};           // OK: Stack<std::string> deduced since C++17
```

更多规则和用法可以看：**Class template argument deduction (CTAD) (since C++17)[1]**

（完）

### 参考资料

1. [Class template argument deduction (CTAD) (since C++17)](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

# （三）—— 非类型模板参数

模板参数不一定非得是类型，它们还可以是普通的数值（ Nontype Template Parameters）。我们仍然使用前面文章的 Stack 的例子。

## 类模板的非类型模板参数

声明：

```cpp
template <typename T, std::size_t Maxsize>
class Stack {
private:
  std::array<T, Maxsize> elems; // elements
  std::size_t numElems;         // current number of elements
public:
  Stack();                  // constructor
  void push(T const &elem); // push element
  void pop();               // pop element
  T const &top() const;     // return top element
  bool empty() const {      // return whether the stack is empty
    return numElems == 0;
  }
  std::size_t size() const { // return current number of elements
    return numElems;
  }
};
```

实现：

```cpp
template <typename T, std::size_t Maxsize>
Stack<T, Maxsize>::Stack() : numElems(0)  {
  // nothing else to do
}

template <typename T, std::size_t Maxsize>
void Stack<T, Maxsize>::push(T const &elem) {
  assert(numElems < Maxsize);
  elems[numElems] = elem;
  ++numElems;
}
```

使用：

```cpp
Stack<int,20> int20Stack;       // stack of up to 20 ints
Stack<int,40> int40Stack;       // stack of up to 40 ints
Stack<std::string,40> stringStack;     // stack of up to 40 strings
```

这个很简单，就不细说了。

## 函数模板的非类型模板参数

```cpp
template<int Val, typename T>
T addValue (T x) {
return x + Val;
}

std::transform(source.begin(), source.end(), dest.begin(), addValue<5, int>);
```

再比如标准库`type_traits`中的`enable_if`和`conditional`:

```cpp
template <bool _Bp, class _If, class _Then>
    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};

template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
```

## 限制

必须是下面的类型：

- 整型常量/枚举
- 指向对象/函数/成员变量的指针
- 对象/函数的左值引用
- std::nullptr_t

当传递指针或者引用时，指向的对象不能是字符串常量、临时变量、数据成 员以及其它子对象。

## 使用 auto 推断非类型模板参数

从 c++17 起，可以使用 auto 推断非类型模板参数：

```cpp
template <auto value> void f() { }

f<10>();               // deduces int
```

如果没有 auto，想将非类型模板参数的类型也当做模板参数，那么必须声明两个模板参数：

```cpp
template <typename Type, Type value> constexpr Type TConstant = value;

constexpr auto const MySuperConst = TConstant<int, 100>;
```

从 c++17 开始，只需要一个 auto 即可：

```cpp
template <auto value> constexpr auto TConstant = value;

constexpr auto const MySuperConst = TConstant <100>;
```

在 auto 推导的的情况下获取类型：

```cpp
template<auto Val, typename T = decltype(Val)>
T foo();
```

或者:

```cpp
template<auto Val> struct Value {
   using ArgType = decltype(Val);
};
```

`template<decltype(auto) N>`也是可以的，这里 N 会被推断成引用类型：

```cpp
template<decltype(auto) N>
class C {
...
};
int i;
C<(i)> x;      // N is int&
```

# （四）—— 可变参数模板 Variadic Template

模板参数接收任意数量的参数。

## 定义与使用

定义：

```cpp
void print() {}

template <typename T, typename... Types>
void print(T firstArg, Types... args) {
  std::cout << firstArg << '\n'; // print first argument
  print(args...);                // call print() for remaining arguments
}
```

使用：

```cpp
std::string s("world");
print (7.5, "hello", s);
```

C 和 GO 都有类似的概念和定义方式，很好理解。定义`void print() {}`是为了终止递归。

`args`被叫做`function parameter pack`.

## sizeof...

返回`parameter pack`个数：

```cpp
template<typename T, typename... Types>
void print (T firstArg, Types... args)
{
  std::cout << sizeof...(Types) << '\n';         // print number of remaining types
  ...
}
```

也许有人会想利用`sizeof...`来判断：只有当可变参数模板的参数个数大于 0 时，才调用`print`，这样可以省略`void print() {}`：

```cpp
template <typename T, typename... Types>
void print(T firstArg, Types... args) {
  std::cout << firstArg << '\n';
  if (sizeof...(args) > 0) { // error if sizeof...(args)==0
    print(args...);          // and no print() for no arguments declared
  }
}
```

但是这样是错误的，因为模板在编译阶段也会将 if 的所有代码都进行编译，而不会去根据 if 的条件去进行选择性的编译，选择运行 if 的哪个分支是在运行期间做的。

### Compile-Time If

但是 c++17 引入了编译期的 if（Compile-Time If），所以上面的代码可以这么写:

```cpp
template <typename T, typename... Types>
void print(T const &firstArg, Types const &... args) {
  std::cout << firstArg << '\n';
  if constexpr (sizeof...(args) > 0) {
    print(args...); // code only available if sizeof...(args)>0 (since C++17)
  }
}
```

`if constexpr`是 c++17 中编译期 if 的语法。这样就可以进行在编译期决定编译 if 条件的哪个分支。再举个例子：

```cpp
template <typename T>
std::string asString(T x)
{
    if constexpr(std::is_same_v<T, std::string>) {
        return x;   //如果T不是string就是无效的语句
    }
    else if constexpr(std::is_arithmetic_v<T>) {
        return std::to_string(x);   //如果x不是数字就是无效的语句
    }
    else {
        return std::string(x);  //如果不能转换为string就是无效的语句。
    }
}
```

## 折叠表达式 Fold Expressions

从 c++17 开始，折叠表达式可以将二元运算符作用于所有`parameter pack`的参数上：

![img](https://pic2.zhimg.com/80/v2-ad4d3da65db2e2984c8b3a718e517cf5_720w.webp)

比如求`parameter pack`的和：

```cpp
template<typename... T>
auto foldSum (T... s) {
  return (... + s);           // ((s1 + s2) + s3) ...
}
```

再比如上面的`print`例子可以简写成：

```cpp
template<typename... Types>
void print (Types const&... args) {
  (std::cout << ... << args) << '\n';
}
```

如果想要在每个参数中间输出空格，可以配合 lambda:

```cpp
template <typename FirstType, typename... Args>
void print(FirstType first, Args... args) {
  std::cout << first;

  auto printWhiteSpace = [](const auto arg) { std::cout << " " << arg; };

  (..., printWhiteSpace(args));
}

int main() {
  print("hello","world","zhangyachen");
}
```

其中， `(..., printWhiteSpace(args));`会被展开为：`printWhiteSpace(arg1), printWhiteSpace(arg2), printWhiteSpace(arg3)`这样的格式。

## 其他场景

### Variadic Expressions

比如将每个`parameter pack`的参数 double：

```cpp
template<typename... T>
void printDoubled (T const&... args) {
  print (args + args...);
}

printDoubled(7.5, std::string("hello"), std::complex<float>(4,2));
```

上面的调用会展开为：

```cpp
print(7.5 + 7.5,
std::string("hello") + std::string("hello"),
std::complex<float>(4,2) + std::complex<float>(4,2);
```

如果只是想加 1，可以改为：

```cpp
template<typename... T>
void addOne (T const&... args) {
  print (args + 1...);        // ERROR: 1... is a literal with too many decimal points
  print (args + 1 ...);     // OK
  print ((args + 1)...);    // OK
}
```

还可以用在`Compile-time Expression`中，比如下面的函数会判断所有的参数类型是否一致：

```cpp
template<typename T1, typename... TN>
constexpr bool isHomogeneous (T1, TN...) {
  return (std::is_same<T1,TN>::value && ...);        // since C++17
}

isHomogeneous(43, -1, "hello");
```

上面的调用会展开为：

```cpp
std::is_same<int,int>::value && std::is_same<int,char const*>::value       // false
```

### Variadic Indices

```cpp
template<typename C, typename... Idx>
void printElems (C const& coll, Idx... idx) {
  print (coll[idx]...);
}

std::vector<std::string> coll = {"good", "times", "say", "bye"};
printElems(coll,2,0,3);
```

最后的调用相当于：

```cpp
print (coll[2], coll[0], coll[3]);
```

### Variadic Class Templates

比如标准库的 Tuple:

```cpp
template<typename... Elements>
class Tuple;

Tuple<int, std::string, char> t; // t can hold integer, string, and character
```

### Variadic Deduction Guides

```cpp
namespace std {
template <typename T, typename... U>
array(T, U...)
    -> array<enable_if_t<(is_same_v<T, U> && ...), T>, (1 + sizeof...(U))>;
}

std::array a{42,45,77};
```

关键点：

- `enable_if_t`控制是否启用该模板。 这个后面文章会讲到。
- `is_same_v<T, U> && ...`判断数组元素类型是否相同，跟上面提到的例子用法一样。

### Variadic Base Classes and using

c++17 的新特性，中文翻译应该叫：变长的 using 声明。**C++17 尝鲜：变长 using 声明[1]**这篇文章关于 using 的来龙去脉讲的很清楚，推荐大家看看。

一个更实际的例子：

```cpp
class Customer {
private:
  std::string name;

public:
  Customer(std::string const &n) : name(n) {}
  std::string getName() const { return name; }
};

struct CustomerEq {
  bool operator()(Customer const &c1, Customer const &c2) const {
    return c1.getName() == c2.getName();
  }
};

struct CustomerHash {
  std::size_t operator()(Customer const &c) const {
    return std::hash<std::string>()(c.getName());
  }
};

// define class that combines operator() for variadic base classes:
template <typename... Bases> struct Overloader : Bases... {
  using Bases::operator()...; // OK since C++17
};

int main() {
  // combine hasher and equality for customers in one type:
  using CustomerOP = Overloader<CustomerHash, CustomerEq>;
  std::unordered_set<Customer, CustomerHash, CustomerEq> coll1;
  std::unordered_set<Customer, CustomerOP, CustomerOP> coll2;
  ...
}
```

这里给 unordered_set 提供自定义的`Hash`和`KeyEqual`。

关于可变参数模板的应用场景和各种使用技巧有很多，这里只列了 5 种大方向的应用场景，但是起码下次遇到看不懂的地方时，知道往哪个大方向去查，不至于一头雾水 ：）

### 参考资料
1. [C++17 尝鲜：变长 using 声明](https://www.cnblogs.com/zwvista/p/9256655.html)

# （五）—— 理解模板参数推导规则

首先我们定义一下本文通用的模板定义与调用：

```cpp
template<typename T>
void f(ParamType param);

......
f(expr); // call f with some expression
```

在编译阶段使用`expr`来推断`ParamType`和`T`这两个类型。这两个类型通常不同，因为`ParamType`会有`const`和引用等修饰。例如：

```cpp
template<typename T>
void f(const T& param);      // ParamType is const T&

int x = 0;
f(x);      // call f with an int
```

这里，T 被推断成`int`，但是`ParamType`的类型是`const T&`。

直觉下`T`的类型应该和`expr`的一样，比如上面的例子中，`expr`和`T`的类型都是`int`。但是会有一些例外情况：`T`的类型不仅依赖`expr`，还依赖`ParamType`。总共分为三大类：

- `ParamType`是一个指针或者引用，但不是`universal reference`(或者叫`forwarding references`).
- `ParamType`是一个`universal reference`。
- `ParamType`既不是指针也不是引用。

## Case 1 : ParamType 是一个指针或者引用，但不是 universal reference

- 如果`expr`是一个引用，忽略其引用部分。
- 比较`expr`与`ParamType`的类型来决定`T`的类型。

### T&

```cpp
template<typename T>
void f(T& param);       // param is a reference

......
int x = 27;                  // x is an int
const int cx = x;       // cx is a const int
const int& rx = x;     // rx is a reference to x as a const int

// call f
f(x);            // T is int, param's type is int&
f(cx);          // T is const int,  param's type is const int&
f(rx);         // T is const int,  param's type is const int&
```

上面例子是左值引用，但是这点对右值引用也适用。 **注意第三点，`const`修饰符依旧保留。** 这和普通函数的类似调用有区别：

```cpp
void f(int &x){

}

...
const int x  = 10;
f(x);       // error
```

### const T&

如果给`ParamType`加上`const`，情况也没有太大变化：

```cpp
template<typename T>
void f(const T& param);        // param is now a ref-to-const

......
int x = 27;                // as before
const int cx = x;     // as before
const int& rx = x;    // as before

......
f(x);         // T is int, param's type is const int&
f(cx);     // T is int, param's type is const int&
f(rx);      // T is int, param's type is const int&
```

### T\*

改为指针也一样：

```cpp
template<typename T>
void f(T* param); // param is now a pointer

......
int x = 27;
const int *px = &x;

f(&x);               // T is int, param's type is int*
f(px);              // T is const int, param's type is const int*
```

## Case 2 : ParamType 是 Universal Reference

- 如果`expr`是左值，那么`T`和`ParamType`会被推断为左值引用。
- 如果`expr`是右值，那么就是 Case 1 的情况。

```cpp
template<typename T>
void f(T&& param);       // param is now a universal reference

......
int x = 27;
const int cx = x;
const int& rx = x;
```

调用：

```cpp
f(x);          // x is lvalue, so T is int&, param's type is also int&
f(cx);         // cx is lvalue, so T is const int&, param's type is also const int&
f(rx);        // rx is lvalue, so T is const int&, param's type is also const int&
f(27);        // 27 is rvalue, so T is int, param's type is therefore int&&
```

如果之前了解过完美转发和折叠引用的概念，结合 Case1，这一个规则还是比较好理解的。

### 注意区别 Universal Reference 与右值引用

这两点需要区分清楚，比如：

```cpp
template<typename T>
void f(T&& param);           // universal reference


template<typename T>
void f(std::vector<T>&& param);       // rvalue reference
```

有一个通用规则 ： `universal reference`会有类型推断的过程。具体在后面的单独文章会讲，跟这篇文章的主题关系不大，这里稍微提一下 : )

## Case 3 : ParamType 既不是指针也不是引用

这种情况就是 pass-by-value 的情况：

```cpp
template<typename T>
void f(T param); // param is now passed by value
```

这意味着，param 是一个被拷贝的全新对象，也就是 param 决定着 T 的类型：

- 如果`expr`是引用类型，忽略。
- 如果`expr`带有 const、volatile，忽略。

```cpp
int x = 27;
const int cx = x;
const int& rx = x;
f(x);         // T's and param's types are both int
f(cx);      // T's and param's types are again both int
f(rx);      // T's and param's types are still both int
```

忽略 const 和 volatile 也比较好理解：参数是值拷贝，所以形参和实参其实是互相独立的。正如下面代码可以将`const int`传递给`int`，但是声明为引用则不行：

```cpp
void f(int x){

}

int main() {
  const int x  = 10;

  f(x);
}
```

注意忽略的 const 是针对参数本身的，而不针对指针指向的 const 对象：

```cpp
template<typename T>
void f(T param);

......
const char* const ptr = "Fun with pointers";       // ptr is const pointer to const object
f(ptr);             // pass arg of type const char * const
```

这个按照值传递的是 ptr，所以 ptr 的 const 会被忽略，但是 ptr 指向的对象依然是 const。

## 数组作为参数

数组类型和指针类型是两种类型，但是有时候他们是可以互换的，比如在下面这种情况下，数组会 decay 成指针：

```cpp
const char name[] = "J. P. Briggs";     // name's type is const char[13]
const char * ptrToName = name;       // array decays to pointer
```

在普通函数中，函数形参为数组类型和指针类型是等价的：

```cpp
void myFunc(int param[]);
void myFunc1(int* param);         // same function as above
```

但是数组作为模板参数是比较特殊的一种情况。

### ParamType 按值传递

```cpp
template<typename T>
void f(T param); // template with by-value parameter

......
const char name[] = "J. P. Briggs";     // name's type is  const char[13]

f(name);           // name is array, but T deduced as const char*
```

这种情况下，`T`被推断为指针类型`const char*`.

### ParamType 为引用类型

```cpp
template<typename T>
void f(T& param);

......
const char name[] = "J. P. Briggs";     // name's type is  const char[13]
f(name);             // pass array to f
```

现在`T`被推断为数组类型`const char [13]`，`ParamType`为`const char (&)[13]`，这种情况是很特殊的，要与`ParamType`按值传递区分开。

我们可以利用上面这种特性定义一个模板来推断数组的大小，这种用法还蛮常见的：

```cpp
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept  {
    return N;
}

......
int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 };
std::array<int, arraySize(keyVals)> mappedVals;
```

![img](https://pic1.zhimg.com/80/v2-658e5389125e9140cc44ff4f9d12a4b8_720w.webp)

## 函数作为参数

上面讨论的关于数组的情况同样适用于函数作为参数，函数类型同样也可以`decay`成函数指针：

```cpp
void someFunc(int, double);        // someFunc is a function;type is void(int, double)
template <typename T> void f1(T param);     // in f1, param passed by value
template <typename T> void f2(T &param);    // in f2, param passed by ref
f1(someFunc);        // param deduced as ptr-to-func; type is void (*)(int, double)
f2(someFunc);      // param deduced as ref-to-func; type is void (&)(int, double)
```

不过这在平时应用中也没有太大差别。

# （六）—— 理解auto推导规则

上篇文章讲了模板参数的推导规则，其实 auto 的推导规则跟模板参数的推导基本上一样的，都是推导参数嘛。比如上篇文章的模板基本结构是：

```cpp
template<typename T>
void f(ParamType param);

......
f(expr);
```

编译器使用 expr 来推断`ParamType`和`T`。

那么对应在 auto 推导中，auto 就对应了`T`，变量的`type specifier`就是`ParamType`：

```cpp
auto x = 27;
const auto cx = x;
const auto& rx = x;
```

这里，cx 的`type specifier`就是`const auto`，rx 的`type specifier`就是`const auto&`.

我们可以想象成在推导 auto 类型时，编译器就是在做一次模板参数类型推断：

- 推断 x :

```cpp
template<typename T>
void func_for_x(T param);

func_for_x(27);
```

- 推断 cx :

```cpp
template<typename T>
void func_for_cx(const T param);

func_for_cx(x);
```

- 推断 rx :

```cpp
template<typename T>
void func_for_rx(const T& param);

func_for_rx(x);
```

在模板参数推导中，我们根据`ParamType`将情况分成了三类。在 auto 推导中，我们同样可以根据`type specifier`来分成三种情况：

- `type specifier`是一个指针或者引用，但不是 universal reference(或者叫 forwarding references).
- `type specifier`是一个 universal reference。
- `type specifier`既不是指针也不是引用。

![img](https://pic1.zhimg.com/80/v2-9cdaa59b3f6b2f71e72003cd564b5790_720w.webp)

## Case 1 : type specifier 是一个指针或者引用，但不是 universal reference

```cpp
const auto& rx = x;
```

上面分析过，不再赘述。

![img](https://pic2.zhimg.com/80/v2-1c8ed946dd1672760812485958587b69_720w.webp)

## Case 2 : type specifier 是一个 universal reference

```cpp
auto&& uref1 = x;         // x is int and lvalue, so uref1's type is int&
auto&& uref2 = cx;      // cx is const int and lvalue, so uref2's type is const int&
auto&& uref3 = 27;     // 27 is int and rvalue, so uref3's type is int&&
```

![img](https://pic2.zhimg.com/80/v2-3c6a290554710ba68865aef2e7fcf96d_720w.webp)

## Case 3 : type specifier 既不是指针也不是引用

```cpp
auto x = 27;
const auto cx = x;
```

![img](https://pic2.zhimg.com/80/v2-3c6a290554710ba68865aef2e7fcf96d_720w.webp)

**注意这个 Case 的情况，假如我们有个函数返回引用，我们使用 auto 接收返回值，如果我们想改变函数的返回值，那么必须用 auto&，而不是 auto，因为这里和函数模板参数推断规则一样，是 pass-by-value，会忽略引用、const 和 volatile：**

```cpp
int x = 50;

int &f() { return x; }

int main() {

  auto a1 = f();
  a1 = 10;        // x = 50

  auto &a2 = f();
  a2 = 20;      // x = 20

  return 0;
}
```

## 数组和函数类型推断

在函数模板参数推断中讨论了数组和函数作为模板参数的推断情况，在 auto 类型推断中情况也是相同的：

```cpp
const char name[] = "R. N. Briggs";

auto arr1 = name;            // arr1's type is const char*
auto& arr2 = name;        // arr2's type is const char (&)[13]

void someFunc(int, double);

auto func1 = someFunc;              // func1's type is void (*)(int, double)
auto& func2 = someFunc;           // func2's type is void (&)(int, double)
```

## auto 与函数模板参数推断的区别

从 C++11 起有 4 种选择可以定义一个整形变量：

```cpp
auto x1 = 27;
auto x2(27);
auto x3 = { 27 };
auto x4{ 27 };
```

最后两种是 C++11 的新特性：统一初始化（uniform initialization），就是这个造成了模板参数推导和 auto 类型推导的最大区别 ：

```cpp
auto x1 = 27;                 // type is int, value is 27
auto x2(27);                 // type is int, value is 27

auto x3 = { 27 };           // type is std::initializer_list<int>, value is { 27 }
auto x4{ 27 };               // type is std::initializer_list<int>, value is { 27 }
```

**特殊点在于：如果使用`uniform initialization`来进行 auto 类型推断，那么最终 auto 推断出的结果是`std::initializer_list<int>`**

**（注 ： 2014年C++标准委员会通过了[N3922](https://link.zhihu.com/?target=http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html)提案，上述的auto x4{27}，x4的类型为init，不是std::initializer_list<int>）**

所以下面的代码会编译报错：

```cpp
template <typename T>
void f(T param);

f({11, 23, 9});
```

但是如果指定`ParamType`为`std::initializer_list<T>`，则可以正确的推断 T 的类型：

```cpp
template<typename T>
void f(std::initializer_list<T> initList);

f({ 11, 23, 9 });        // T deduced as int, and initList's type is std::initializer_list<int>
```

### C++14 中更特殊的情况

在 C++14 中，允许将函数返回值和 lambda 参数声明为 auto，**但是在这种情况下，auto 的类型推断使用的是模板参数类型推断规则：**

```cpp
auto createInitList() {
  return { 1, 2, 3 };             // error: can't deduce type for { 1, 2, 3 }
}

std::vector<int> v;

…
auto resetV = [&v](const auto& newValue "&v") { v = newValue; };           // C++14

…
resetV({ 1, 2, 3 }); // error! can't deduce type  for { 1, 2, 3 }
```

# （七）—— 模板参数之按值传递 vs 按引用传递

## 按值传递

大多数人不喜欢将参数设置为按值传递的原因是怕参数拷贝的过程中带来的性能问题，但是不是所有按值传递都会有参数拷贝，比如：

```cpp
template<typename T>
void printV (T arg) {
...
}

std::string returnString();
std::string s = "hi";
printV(s);                        // copy constructor
printV(std::string("hi"));        // copying usually optimized away (if not, move constructor)
printV(returnString());           // copying usually optimized away (if not, move constructor)
printV(std::move(s));            // move constructor
```

我们逐一看一下上面的 4 个调用：

- 第一个 : 我们传递了一个 lvalue，这会使用 std::string 的`copy constructor`。
- 第二和第三个 : 这里传递的是 prvalue(随手创建的临时对象或者函数返回的临时对象)，一般情况下编译器会进行参数传递的优化，不会导致`copy constructor` （**这个也是 C++17 的新特性：Mandatory Copy Elision or Passing Unmaterialized Objects[1]）**
- 第四个 : 传递的是 xvalue(一个使用过 std::move 后的对象)，这会调用`move constructor`。

虽然上面 4 种情况只有第一种才会调用`copy constructor`，但是这种情况才是最常见的。

### Decay

**之前的文章介绍过，当模板参数是值传递时，会造成参数 decay:**

- 丢失 const 和 volatile 属性。
- 丢失引用类型。
- 传递数组时，模板参数会 decay 成指针。

```cpp
template<typename T>
void printV (T arg) {
...
}

std::string const c = "hi";
printV(c);         // c decays so that arg has type std::string
printV("hi");    // decays to pointer so that arg has type char const*
int arr[4];
printV(arr);    // decays to pointer so that arg has type char const*
```

这种方式有优点也有缺点：

- 优点：能够统一处理 decay 后的指针，而不必区分是`char const*`还是类似`const char[13]`。
- 缺点：无法区分传递的是一个数组还是一个指向单一元素的指针，因为 decay 后的类型都是`char const*`

## 按引用传递

按引用传递不会拷贝参数，也不会有上面提到的 decay。这看起来很美好，但是有时候也会有问题：

### 传递 const reference

```cpp
template<typename T>
void printR (const T& arg) {
...
}

std::string returnString();
std::string s = "hi";
printR(s);         // no copy
printR(std::string("hi"));     // no copy
printR(returnString());       // no copy
printR(std::move(s));         // no copy
```

还是上面的例子，但是当模板参数声明改为`const T&`后，所有的调用都不会有拷贝。那么哪里会有问题呢？

大家都知道，传递引用时，实际传递的是一个地址，那么编译器在编译时不知道调用者会针对这个地址做什么操作。理论上，调用者可以随意改变这个地址指向的值（这里虽然声明为 const，但是仍然有`const_cast`可以去除 const）。因此，编译器会假设所有该地址的缓存（通常为寄存器）在该函数调用后都会失效，如果要使用该地址的值，会重新从内存中载入。

### 引用不会 Decay

之前文章介绍过，按引用传递不会 decay。因此如果传递的数组，那么推断参数类型时不会 decay 成指针，并且 const 和 volatile 都会被保留。

```cpp
template<typename T>
void printR (T const& arg) {
...
}

std::string const c = "hi";
printR(c);         // T deduced as std::string, arg is std::string const&
printR("hi");      // T deduced as char[3], arg is char const(&)[3]

int arr[4];
printR(arr);       // T deduced as int[4], arg is int const(&)[4]
```

因此，在 printR 函数内通过 T 声明的变量没有 const 属性。

### 传递 nonconst reference

如果想改变参数的值并且不希望拷贝，那么会使用这种情况。但是这时我们不能绑定 prvalue 和 xvalue 给一个 nonconst reference（这是 c++的一个**规则[2]**）

```cpp
template<typename T>
void outR (T& arg) {
...
}

std::string returnString();
std::string s = "hi";
outR(s);          // OK: T deduced as std::string, arg is std::string&
outR(std::string("hi"));       // ERROR: not allowed to pass a temporary (prvalue)
outR(returnString());        // ERROR: not allowed to pass a temporary (prvalue)
outR(std::move(s));          // ERROR: not allowed to pass an xvalue
```

同样，这种情况不会发生 decay:

```cpp
int arr[4];
outR(arr);          // OK: T deduced as int[4], arg is int(&)[4]
```

### 传递 universal reference

这个也是声明参数为引用的一个重要场景：

```cpp
template<typename T>
void passR (T&& arg) { // arg declared as forwarding reference
...
}

std::string s = "hi";
passR(s);        // OK: T deduced as std::string& (also the type of arg)
passR(std::string("hi"));     // OK: T deduced as std::string, arg is std::string&&
passR(returnString());        // OK: T deduced as std::string, arg is std::string&&
passR(std::move(s));       // OK: T deduced as std::string, arg is std::string&&
passR(arr);          // OK: T deduced as int(&)[4] (also the type of arg)
```

但是这里需要额外注意一下，这是 T 隐式被声明为引用的唯一情况：

```cpp
template <typename T>
void passR(T &&arg) {     // arg is a forwarding reference
  T x;        // for passed lvalues, x is a reference, which requires an initializer
  ...
}
foo(42);    // OK: T deduced as int
int i;
foo(i);    // ERROR: T deduced as int&, which makes the declaration of x in passR() invalid
```

## 使用 std::ref()和 std::cref()

主要用来“喂”reference 给函数模板，后者原本以按值传递的方式接受参数，这往往允许函数模板得以操作 reference 而不需要另写特化版本：

```cpp
template <typename T>
void foo (T val) ;

...
int x;
foo (std: :ref(x));
foo (std: :cref(x));
```

这个特性被 C++标准库运用于各个地方，例如:

- `make_pair()`用此特性于是能够创建一个 pair<> of references.
- `make_tuple()`用此特性于是能够创建一个 tuple<> of references.
- `Binder`用此特性于是能够绑定(bind) reference.
- `Thread`用此特性于是能够以 by reference 形式传递实参。

注意 std::ref()不是真的将参数变为引用，只是创建了一个 std::reference_wrapper<>对象，该对象引用了原始的变量，然后将 std::reference_wrapper<>传给了参数。**std::reference_wrapper<>支持的一个重要操作是：向原始类型的隐式转换：**

```cpp
#include <functional> // for std::cref()
#include <string>
#include <iostream>

void printString(std::string const& s) {
  std::cout << s << '\n';
}

template<typename T>
void printT (T arg) {
  printString(arg);     // might convert arg back to std::string
}

int main() {
  std::string s = "hello";
  printT(s); // print s passed by value
  printT(std::cref(s)); // print s passed "as if by reference"
}
```

## 区分指针和数组

前面说过，按值传递的一个缺点是，无法区分调用参数是数组还是指针，因为数组会 decay 成指针。那如果有需要区分的需求，可以这么写：

```cpp
template <typename T, typename = std::enable_if_t<std::is_array_v<T>>>
void foo(T &&arg1, T &&arg2) {
  ...
}
```

`std::enable_if`后面会介绍，它的意思是，假如不符合 enable_if 设置的条件，那么该模板会被禁用。

其实现在基本上也不用原始数组和字符串了，都用 std::string、std::vector、std::array。但是假如写模板的话，这些因素还是需要考虑进去。

## 处理返回值

一般在下面情况下，返回值会被声明为引用：

- 返回容器或者字符串中的元素(eg. operator[]、front())
- 修改类成员变量
- 链式调用(operator<<、operator>>、operator=)

但是将返回值声明为引用需要格外小心：

```cpp
auto s = std::make_shared<std::string>("whatever");
auto& c = (*s)[0];
s.reset();
std::cout << c;     // run-time ERROR
```

### 确保返回值为值传递

如果你确实想将返回值声明为值传递，仅仅声明 T 是不够的：

- forwarding reference 的情况，这个上面讨论过

```cpp
template<typename T>
T retR(T&& p) {
    return T{...};        // OOPS: returns by reference when called for lvalues
}
```

- 显示的指定模板参数类型：

```cpp
template<typename T>  // Note: T might become a reference
T retV(T p) {
  return T{...}; // OOPS: returns a reference if T is a reference
}

int x;
retV<int&>(x);     // retT() instantiated for T as int&
```

所以，有两种方法是安全的：

- std::remove_reference<> :

```cpp
template<typename T>
typename std::remove_reference<T>::type retV(T p) {
  return T{...};     // always returns by value
}
```

- auto :

```cpp
template<typename T>
auto retV(T p)  {     // by-value return type deduced by compiler
  return T{...};      // always returns by value
}
```

之前文章讨论过 auto 推断类型的规则，会忽略引用。

## 模板参数声明的推荐

- 按值传递
  - 数组和字符串会 decay。
  - 性能问题(可以使用 std::ref 和 std::cref 来避免，但是要小心这么做是有效的)。
- 按引用传递
  - 性能更好。
  - 需要 forwarding references，并且注意此时模板参数为隐式的引用类型。
  - 需要对参数是数组和字符串的情况额外关注。

### 一般性建议

对应模板参数，一般建议如下：

- 默认情况下，使用按值传递。理由：
  - 简单，尤其是对于参数是数组和字符串的情况。
  - 对于小对象而言，性能也不错。调用者可以使用 std::ref 和 std::cref.
- 有如下理由时，使用按引用传递：
  - 需要函数改变参数的值。
  - 需要 perfect forwarding。
  - 拷贝参数的性能不好。
- 如果你对自己的程序足够了解，当然可以不遵守上面的建议，但是不要仅凭直觉就对性能做评估。最好的方法是：测试。

### 不要将模板参数设计的太通用

比如你的模板函数只想接受 vector，那么完全可以定义成：

```cpp
template<typename T>
void printVector (const std::vector<T>& v) {
  ...
}
```

这里就没有必要定义为`const T& v`.

## std::make_pair()模板参数历史演进

`std::make_pair()`是一个很好演示模板参数机制的例子：

- 在 C++98 中，`make_pair<>()`的参数被设计为按引用传递来避免不必要的拷贝：

```cpp
template<typename T1, typename T2>
pair<T1,T2> make_pair (T1 const& a, T2 const& b) {
  return pair<T1,T2>(a,b);
}
```

但是当使用存储不同长度的字符串或者数组时，这样做会导致严重的问题。 这个问题记录在**See C++ library issue 181 [LibIssue181][3]**

- 于是在 C++03 中，模板参数改为了按值传递：

```cpp
template<typename T1, typename T2>
pair<T1,T2> make_pair (T1 a, T2 b) {
  return pair<T1,T2>(a,b);
}
```

- C++11 引入了移动语义，于是定义又改为(真实定义要比这个复杂一些)：

```cpp
template <typename T1, typename T2>
constexpr pair<typename decay<T1>::type, typename decay<T2>::type>
make_pair(T1 &&a, T2 &&b) {
  return pair<typename decay<T1>::type, typename decay<T2>::type>(
      forward<T1>(a), forward<T2>(b));
}
```

标准库中 perfect forward 和 std::decay 是常见的搭配。

(完)

### 参考资料

1. ~~[Mandatory Copy Elision or Passing Unmaterialized Objects](http://www.cplusplus2017.info/c17-guaranted-copy-elision/)~~
2. [规则](https://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object)
3. [See C++ library issue 181 [LibIssue181]](https://cplusplus.github.io/LWG/issue181)

# （八）—— enable_if<>与SFINAE

## 引子

```cpp
class Person {
private:
  std::string name;

public:
  // generic constructor for passed initial name:
  template <typename STR>
  explicit Person(STR &&n) : name(std::forward<STR>(n)) {
    std::cout << "TMPL-CONSTR for '" << name << "'\n";
  }

  // copy and move constructor:
  Person(Person const &p) : name(p.name) {
    std::cout << "COPY-CONSTR Person '" << name << "'\n";
  }

  Person(Person &&p) : name(std::move(p.name)) {
    std::cout << "MOVE-CONSTR Person '" << name << "'\n";
  }
};
```

构造函数是一个 perfect forwarding，所以：

```cpp
std::string s = "sname";
Person p1(s);         // init with string object => calls TMPL-CONSTR
Person p2("tmp");     // init with string literal => calls TMPL-CONSTR
```

但是当尝试调用 `copy constructor` 时会报错：

```cpp
Person p3(p1);    // ERROR
```

但是如果参数是const Person或者move constructor则正确：

```cpp
Person const p2c("ctmp");    // init constant object with string literal
Person p3c(p2c);             // OK: copy constant Person => calls COPY-CONSTR

Person p4(std::move(p1));    // OK: move Person => calls MOVE-CONST
```

**原因是：根据c++的重载规则，对于一个`nonconstant lvalue Person p`，member template**

```cpp
template<typename STR>
Person(STR&& n)
```

**会优于 copy constructor**

```cpp
Person (Person const& p)
```

因为STR会直接被substituted为Person&，而copy constructor还需要一次const转换。

也许提供一个nonconstant copy constructor会解决这个问题，但是我们真正想做的是当参数是Person类型时，禁用掉member template。这可以通过`std::enable_if<>`来实现。

## 使用enable_if<>禁用模板

```cpp
template<typename T>
typename std::enable_if<(sizeof(T) > 4)>::type
foo() {
}
```

当`sizeof(T) > 4`为False时，该模板就会被忽略。如果`sizeof(T) > 4`为true时，那么该模板会被扩展为：

```cpp
void foo() {
}
```

std::enable_if<>是一种类型萃取（type trait），会根据给定的一个编译时期的表达式（第一个参数）来确定其行为：

- 如果这个表达式为true，`std::enable_if<>::type`会返回：
  - 如果没有第二个模板参数，返回类型是void。
  - 否则，返回类型是其第二个参数的类型。
- 如果表达式结果false，`std::enable_if<>::type`不会被定义。根据下面会介绍的SFINAE(substitute failure is not an error)， 这会导致包含std::enable_if<>的模板被忽略掉。

给std::enable_if<>传递第二个参数的例子：

```cpp
template<typename T>
std::enable_if_t<(sizeof(T) > 4), T>
foo() {
return T();
}
```

如果表达式为真，那么模板会被扩展为：

```cpp
MyType foo();
```

如果你觉得将enable_if<>放在声明中有点丑陋的话，通常的做法是：

```cpp
template<typename T,
typename = std::enable_if_t<(sizeof(T) > 4)>>
void foo() {
}
```

当`sizeof(T) > 4`时，这会被扩展为：

```cpp
template<typename T,
typename = void>
void foo() {
}
```

还有种比较常见的做法是配合using：

```cpp
template<typename T>
using EnableIfSizeGreater4 = std::enable_if_t<(sizeof(T) > 4)>;

template<typename T,
typename = EnableIfSizeGreater4<T>>
void foo() {
}
```

## enable_if<>实例

我们使用enable_if<>来解决引子中的问题：

```cpp
template <typename T>
using EnableIfString = std::enable_if_t<std::is_convertible_v<T, std::string>>;

class Person {
private:
  std::string name;

public:
  // generic constructor for passed initial name:
  template <typename STR, typename = EnableIfString<STR>>
  explicit Person(STR &&n) : name(std::forward<STR>(n)) {
    std::cout << "TMPL-CONSTR for '" << name << "'\n";
  }

  // copy and move constructor:
  Person(Person const &p) : name(p.name) {
    std::cout << "COPY-CONSTR Person '" << name << "'\n";
  }
  Person(Person &&p) : name(std::move(p.name)) {
    std::cout << "MOVE-CONSTR Person '" << name << "'\n";
  }
};
```

核心点：

- 使用 using 来简化 `std::enable_if<>` 在成员模板函数中的写法。
- 当构造函数的参数不能转换为 string 时，禁用该函数。

所以下面的调用会按照预期方式执行：

```cpp
int main() {
  std::string s = "sname";
  Person p1(s);          // init with string object => calls TMPL-CONSTR
  Person p2("tmp");      // init with string literal => calls TMPL-CONSTR
  Person p3(p1);          // OK => calls COPY-CONSTR
  Person p4(std::move(p1));       // OK => calls MOVE-CONST
}
```

注意在不同版本中的写法：

- C++17 : `using EnableIfString = std::enable_if_t<std::is_convertible_v<T, std::string>>`
- C++14 : `using EnableIfString = std::enable_if_t<std::is_convertible<T, std::string>::value>`
- C++11 : `using EnableIfString = typename std::enable_if<std::is_convertible<T, std::string>::value>::type`

## 使用 Concepts 简化 enable_if<>

如果你还是觉得enable_if<>不够直观，那么可以使用之前文章提到过的C++20引入的Concept.

```cpp
template<typename STR>
requires std::is_convertible_v<STR,std::string>
Person(STR&& n) : name(std::forward<STR>(n)) {
...
}
```

我们也可以将条件定义为通用的Concept:

```cpp
template<typename T>
concept ConvertibleToString = std::is_convertible_v<T,std::string>;

...
template<typename STR>
requires ConvertibleToString<STR>
Person(STR&& n) : name(std::forward<STR>(n)) {
...
}
```

甚至可以改为：

```cpp
template<ConvertibleToString STR>
Person(STR&& n) : name(std::forward<STR>(n)) {
...
}
```

## SFINAE (Substitution Failure Is Not An Error)

在 C++ 中针对不同参数类型做函数重载时很常见的。编译器需要为一个调用选择一个最适合的函数。

当这些重载函数包含模板函数时，编译器一般会执行如下步骤：

- 确定模板参数类型。
- 将函数参数列表和返回值的模板参数替换掉（substitute）
- 根据规则决定哪一个函数最匹配。

但是替换的结果可能是毫无意义的。这时，编译器不会报错，反而会忽略这个函数模板。

我们将这个原则叫做：SFINAE（“substitution failure is not an error）

但是替换(substitute)和实例化(instantiation)不一样：即使最终不需要被实例化的模板也要进行替换（不然就无法执行上面的第3步）。不过它只会替换直接出现在函数声明中的相关内容（不包含函数体）。

考虑下面的例子：

```cpp
// number of elements in a raw array:
template <typename T, unsigned N> 
std::size_t len(T (&)[N]) { 
  return N; 
}

// number of elements for a type having size_type:
template <typename T> 
typename T::size_type len(T const &t) { 
  return t.size(); 
}
```

当传递一个数组或者字符串时，只有第一个函数模板匹配，因为`T::size_type`导致第二个模板函数会被忽略：

```cpp
int a[10];
std::cout << len(a);        // OK: only len() for array matches
std::cout << len("tmp");      // OK: only len() for array matches
```

同理，传递一个vector会只有第二个函数模板匹配：

```cpp
std::vector<int> v;
std::cout << len(v);    // OK: only len() for a type with size_type matches
```

注意，这与传递一个对象，有size_type成员，但是没有size()成员函数不同。例如：

```cpp
std::allocator<int> x;
std::cout << len(x);     // ERROR: len() function found, but can’t size()
```

编译器会根据SFINAE原则匹配到第二个函数，但是编译器会报找不到`std::allocator<int>`的size()成员函数。在匹配过程中不会忽略第二个函数，而是在实例化的过程中报错。

**而使用 enable_if<> 就是实现 SFINAE 最直接的方式。**

### SFINAE with decltype

有的时候想要为模板定义一个合适的表达式是比较难得。

比如上面的例子，假如参数有size_type成员但是没有size成员函数，那么就忽略该模板。之前的定义为：

```cpp
template<typename T>
typename T::size_type len (T const& t) {
    return t.size();
}


std::allocator<int> x;
std::cout << len(x) << '\n';       // ERROR: len() selected, but x has no size()
```

这么定义会导致编译器选择该函数但是会在instantiation阶段报错。

处理这种情况一般会这么做：

- 通过`trailing return type`来指定返回类型 (auto -> decltype)
- 将所有需要成立的表达式放在逗号运算符的前面。
- 在逗号运算符的最后定义一个类型为返回类型的对象。

比如：

```cpp
template<typename T>
auto len (T const& t) -> decltype( (void)(t.size()), T::size_type() ) {
    return t.size();
}
```

这里，decltype的参数是一个逗号表达式，所以最后的`T::size_type()`为函数的返回值类型。逗号前面的`(void)(t.size())`必须成立才可以。

# （九）—— 理解decltype与decltype(auto)

与模板参数推导和auto推导一样，decltype的结果大多数情况下是正常的，但是也有少部分情况是反直觉的。

## decltype介绍

给定一个name或者expression，decltype会告诉你它的类型。

我们先从正常情况开始：

```cpp
const int i = 0;            // decltype(i) is const int
bool f(const Widget& w);    // decltype(w) is const Widget&
                            // decltype(f) is bool(const Widget&)

struct Point {
  int x, y;         // decltype(Point::x) is int
};          // decltype(Point::y) is int

Widget w;        // decltype(w) is Widget
if (f(w)) …       // decltype(f(w)) is bool

template<typename T>    // simplified version of std::vector
class vector {
public:
…
T& operator[](std::size_t index);
…
};

vector<int> v;      // decltype(v) is vector<int>
…
if (v[0] == 0) …      // decltype(v[0]) is int&
```

很直观，没有例外情况。 **注意：decltype与auto不同，不会消除const和引用。**

## 为什么需要decltype

比如我们需要声明一个函数模板，函数的返回值类型依赖函数参数的类型。在C++11中，常见的例子是返回一个container对应索引的值：

```cpp
template <typename Container, typename Index> // works, but requires refinement
auto authAndAccess(Container &c, Index i) -> decltype(c[i]) {
  return c[i];
}
```

注意：这里的auto跟类型推导没有任何关系，它只是表明了这里使用了C++11的`trailing return type`.

### decltype(auto)

在C++11中只允许单语句的lambda表达式被推导，在C++14中之中行为被拓展到所有lambda和所有函数，包括多语句。在C++14中，上述代码我们可以简写为：

```cpp
template<typename Container, typename Index>        // C++14;  not quite correct
auto authAndAccess(Container& c, Index i) { 
  return c[i];         // return type deduced from c[i]
}
```

**注意：这里的auto就跟类型推导有关系了。** 在前面讲auto推导规则的文章中提到过，auto作用在函数返回值时，使用的是模板参数推导规则，**这里就会出现问题：`operator []`我们希望它返回引用，但是使用auto使用模板参数推导规则时，引用会被忽略，所以下面的代码会报错：**

```cpp
template <typename Container, typename Index>
auto authAndAccess(Container &c, Index i) {
  return c[i];
}

std::vector<int> v{1,2,3,4,5};
authAndAccess(v,2) = 10;      // error: expression is not assignable
```

但是使用`auto -> decltype()`则不会报错，因为这里auto不代表参数参数推导：

```cpp
template <typename Container, typename Index>
auto authAndAccess(Container &c, Index i) -> decltype(c[i]) {
  return c[i];
}

std::vector<int> v{1,2,3,4,5};
authAndAccess(v,2) = 10;
```

所以，要想让authAndAccess在使用auto的情况下返回引用，在C++14中，我们可以使用decltype(auto)：

```cpp
template <typename Container, typename Index>
decltype(auto) authAndAccess(Container &c, Index i) {
  return c[i];
}


std::vector<int> v{1,2,3,4,5};
authAndAccess(v,2) = 10;
```

decltype(auto)中的auto代表返回值需要被自动推导，decltype代表使用decltype来推导返回值类型。

decltype(auto)不仅可以声明函数返回值，还可以声明变量：

```cpp
Widget w;

const Widget& cw = w;       // auto type deduction : myWidget1's type is Widget

decltype(auto) myWidget2 = cw;       // decltype type deduction : myWidget2's type is const Widget& 
```

## 注意(entity)

decltype的规则可以看官网：**[decltype specifier](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/decltype)**，概况下可以分为两大类：

- `decltype ( entity )` : 如果entity是一个不被括号包围的标识符、类访问表达式，那么`decltype ( entity )`与entity类型一致。
- `decltype ( expression )` : 如果expression是一个表达式，计算结果为类型T，那么：
  - 如果expression为xvalue，那么decltype的结果是T&&.
  - 如果expression为lvalue，那么decltype的结果是T&.
  - 如果expression为prvalue，那么decltype的结果是T.

注意第一点中强调了entity是一个**不被括号包围的**标识符。因为当一个标识符被括号包围时，它就是一个左值表达式了，对应上面第二大点的第二小点。比如说`int x = 0;`，x是一个标识符，所以`decltype(x)`的结果为int。但是（x）就是一个左值表达式，`decltype((x))`的结果就是int&。所以下面的用法是不同的：

```cpp
decltype(auto) f1() {
int x = 0;
    …
    return x;       // decltype(x) is int, so f1 returns int
}

decltype(auto) f2() {
    int x = 0;
    …
    return (x);     // decltype((x)) is int&, so f2 returns int&
}
```

官网的例子能很好的概况decltype最常见的用法：

```cpp
#include <iostream>
 
struct A { double x; };
const A* a;
 
decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
 
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) // return type depends on template parameters
                                      // return type can be deduced since C++14
{
    return t + u;
}
 
int main() 
{
    int i = 33;
    decltype(i) j = i * 2;
 
    std::cout << "i = " << i << ", "
              << "j = " << j << '\n';
 
    auto f = [](int a, int b) -> int
    {
        return a * b;
    };
 
    decltype(f) g = f; // the type of a lambda function is unique and unnamed
    i = f(2, 2);
    j = g(3, 3);
 
    std::cout << "i = " << i << ", "
              << "j = " << j << '\n';
}
```

# （十）—— 区分万能引用和右值引用

## 引子

`T&&`在代码里并不总是右值引用：

```cpp
void f(Widget&& param);      // rvalue reference

Widget&& var1 = Widget();      // rvalue reference

auto&& var2 = var1;        // not rvalue reference


template<typename T>
void f(std::vector<T>&& param);      // rvalue reference


template<typename T>
void f(T&& param);     // not rvalue reference
```

`T&&`代表两种含义：

- 右值引用
- 万能引用(universal references, or forwarding references)

## 如何区分

万能引用一般出现在两个场景中：

- 模板参数

```cpp
template<typename T>
void f(T&& param); // param is a universal reference
```

- auto声明

```cpp
auto&& var2 = var1; // var2 is a universal reference
```

我们分别讨论下这两种场景。

### 模板参数

**我们注意到，涉及到万能引用的地方，都会有参数推导的过程，例如上面的T和var2. 而右值引用则没有这个过程：**

```cpp
void f(Widget&& param);        // no type deduction; param is an rvalue reference

Widget&& var1 = Widget();     // no type deduction; var1 is an rvalue reference
```

但是即使语句设计到参数推导，也不一定就是万能引用。例如：

```cpp
template<typename T>
void f(std::vector<T>&& param);       // param is an rvalue reference


std::vector<int> v;
f(v); // error! can't bind lvalue to rvalue reference
```

这点还是比较好理解的。万能引用需要依靠表达式来初始化自己是右值引用还是左值引用，但是上面这个例子没有表现出这一点，它仅仅是推断了T的类型，但是param的类型一直都是`std::vector<T>&&`。

我们再举一个vector中的例子：

```cpp
template<class T, class Allocator = allocator<T>> 
class vector { 
public:

void push_back(T&& x);      // rvalue reference


template <class... Args> 
void emplace_back(Args&&... args);      // universal reference
};
```

- `push_back(T&& x)`中的T&&为右值引用，因为这个虽然是T&&，但是不涉及到参数推导。当push_back被instantiated时，实际的调用类似于：

```cpp
std::vector<Widget> v;

...
class vector<Widget, allocator<Widget>> {
public:
void push_back(Widget&& x);       // rvalue reference
…
};
```

可以很明显的看出此时没有参数推导的过程。

- `template <class... Args> emplace_back(Args&&... args)`中的`Args&&`为万能引用。Args与T是相互独立的，所以Args有一个独立的参数推断过程。

### const disqualify universal reference

有意思的是，当参数加上const后，就一定是右值引用：

```cpp
template <class T> int f(T&& heisenreference);
template <class T> int g(const T&&);

int i;
int n1 = f(i);         // calls f<int&>(int&)
int n2 = f(0);     // calls f<int>(int&&)
int n3 = g(i); // error: would call g<int>(const int&&), which would bind an rvalue reference to an lvalue
```

至于为什么会有这个规定，按照**[Why adding const makes the universal reference as rvalue](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/38814939/why-adding-const-makes-the-universal-reference-as-rvalue)**的说法，大体有两点原因：

- `const T&&`允许你重载一个函数模板，它只接受右值引用。如果`const T&&`也被当做universal reference，那么将没有办法让函数只接受右值引用。
- 显示禁用某个函数接受右值引用：`template <typename T> void cref(const T&&) = delete;`

### auto声明

对于auto的场景来说，所有的`auto&&`都是万能引用，因为它总是有参数推导的过程。例如定义一个记录函数执行时间的lambda（C++14中允许使用auto来声明lambda的函数）：

```cpp
auto timeFuncInvocation = [](auto &&func, auto &&... params) {  
  start timer;
  std::forward<decltype(func)>(func)(                      // invoke func
      std::forward<decltype(params)>(params)...      // on params
  );
  stop timer and record elapsed time;
};
```

# （十一）—— 编写泛型库需要的基本技术

## Callables

许多基础库都要求调用方传递一个可调用的实体（entity）。例如：一个描述如何排序的函数、一个如何 hash 的函数。一般用`callback`来描述这种用法。在 C++中有以下几种形式可以实现 callback，它们都可以被当做函数参数传递并可以直接使用类似`f(...)`的方式调用：

- 指向函数的指针。
- 重载了`operator()`的类（有时被叫做`functors`），包括 lambdas.
- 包含一个可以生成函数指针或者函数引用的转换函数的类。

C++使用`callable type`来描述上面这些类型。比如，一个可以被调用的对象称作`callable object`，我们使用`callback`来简化这个称呼。

编写泛型代码会因为这个用法的存在而可扩展很多。

### 函数对象 Function Objects

例如一个 for_each 的实现：

```cpp
template <typename Iter, typename Callable>
void foreach (Iter current, Iter end, Callable op) {
  while (current != end) {     // as long as not reached the end
    op(*current);              // call passed operator for current element
    ++current;                 // and move iterator to next element
  }
}
```

使用不同的`Function Objects`来调用这个模板：

```cpp
// a function to call:
void func(int i) { std::cout << "func() called for: " << i << '\n'; }

// a function object type (for objects that can be used as functions):
class FuncObj {
public:
  void operator()(int i) const { // Note: const member function
    std::cout << "FuncObj::op() called for: " << i << '\n';
  }
};


int main(int argc, const char **argv) {
  std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19};

  foreach (primes.begin(), primes.end(),  func);    // range function as callable (decays to pointer)
  foreach (primes.begin(), primes.end(), &func);    // range function pointer as callable
  foreach (primes.begin(), primes.end(), FuncObj());// range function object as callable
  foreach (primes.begin(), primes.end(),            // range lambda as callable
           [](int i "") {
             std::cout << "lambda called for: " << i << '\n';
           });
  return 0;
}
```

解释一下：

- `foreach (primes.begin(), primes.end(), func);` 按照值传递时，传递函数会 decay 为一个函数指针。
- `foreach (primes.begin(), primes.end(), &func);` 这个比较直接，直接传递了一个函数指针。
- `foreach (primes.begin(), primes.end(), FuncObj());` 这个是上面说过的`functor`，一个重载了`operator()`的类。所以，当调用`op(*current);`时，实际是在调用`op.operator()(*current);`. ps. 如果不加函数声明后面的 const，在某些编译器中可能会报错。
- Lambda ： 这个和前面情况一样，不解释了。

### 处理成员函数及额外的参数

上面没有提到一个场景 ： 成员函数。因为调用非静态成员函数的方式是`object.memfunc(. . . )`或`ptr->memfunc(. . . )`，不是统一的`function-object(. . . )`。

### std::invoke<>()

幸运的是，从 C++17 起，C++提供了**`std::invoke<>()`[1]**来统一所有的 callback 形式：

![img](https://pic2.zhimg.com/80/v2-e0bacc8307bdba82537159b3be53595d_720w.webp)

```cpp
template <typename Iter, typename Callable, typename... Args>
void foreach (Iter current, Iter end, Callable op, Args const &... args) {
  while (current != end) {     // as long as not reached the end of the elements
    std::invoke(op,            // call passed callable with
                args...,       // any additional args
                *current);     // and the current element
    ++current;
  }
}
```

**那么，`std::invoke<>()`是怎么统一所有 callback 形式的呢？** 注意，我们在 foreach 中添加了第三个参数：`Args const &... args`. invoke 是这么处理的：

- **如果 Callable 是指向成员函数的指针，**它会使用 args 的第一个参数作为类的 this。args 中剩余的参数被传递给 Callable。
- 否则，所有 args 被传递给 Callable。

使用：

```cpp
// a class with a member function that shall be called
class MyClass {
public:
  void memfunc(int i) const {
    std::cout << "MyClass::memfunc() called for: " << i << '\n';
  }
};

int main() {
  std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19};

  // pass lambda as callable and an additional argument:
  foreach (
      primes.begin(), primes.end(),              // elements for 2nd arg of lambda
      [](std::string const &prefix, int i "") {     // lambda to call
        std::cout << prefix << i << '\n';
      },
      "- value: ");    // 1st arg of lambda

  // call obj.memfunc() for/with each elements in primes passed as argument
  MyClass obj;
  foreach (primes.begin(), primes.end(), // elements used as args
           &MyClass::memfunc,            // member function to call
           obj);                         // object to call memfunc() for
}
```

注意在 callback 是成员函数的情况下，是如何调用 foreach 的。

### 统一包装

`std::invoke()`的一个场景用法是：包装一个函数调用，这个函数可以用来记录函数调用日志、测量时间等。

```cpp
#include <utility>               // for std::invoke()
#include <functional>        // for std::forward()

template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&&... args) {
    return std::invoke(std::forward<Callable>(op),  std::forward<Args>(args)...);       // passed callable with any additional args
}
```

一个需要考虑的事情是，如何处理 op 的返回值并返回给调用者：

```cpp
template<typename Callable, typename... Args>
decltype(auto) call(Callable&& op, Args&&... args)
```

这里使用`decltype(auto)`（从 C++14 起）（`decltype(auto)`的用法可以看之前的文章 : c++11-17 模板核心知识（九）—— 理解 decltype 与 decltype(auto)）

如果想对返回值做处理，可以声明返回值为`decltype(auto)`：

```cpp
decltype(auto) ret{std::invoke(std::forward<Callable>(op), std::forward<Args>(args)...)};

...
return ret;
```

但是有个问题，使用`decltype(auto)`声明变量，值不允许为 void，可以针对 void 和非 void 分别进行处理：

```cpp
#include <functional>  // for std::forward()
#include <type_traits> // for std::is_same<> and invoke_result<>
#include <utility>     // for std::invoke()

template <typename Callable, typename... Args>
decltype(auto) call(Callable &&op, Args &&... args) {

  if constexpr (std::is_same_v<std::invoke_result_t<Callable, Args...>, void>) {
    // return type is void:
    std::invoke(std::forward<Callable>(op), std::forward<Args>(args)...);
    ...
    return;
  } else {
    // return type is not void:
    decltype(auto) ret{
        std::invoke(std::forward<Callable>(op), std::forward<Args>(args)...)};
    ...
    return ret;
  }
}
```

`std::invoke_result<>`只有从 C++17 起才能使用，C++17 之前只能用`typename std::result_of<Callable(Args...)>::type`.

## 泛型库的其他基本技术

### Type Traits

这个技术很多人应该很熟悉，这里不细说了。

```cpp
#include <type_traits>

template <typename T>
class C {

  // ensure that T is not void (ignoring const or volatile):
  static_assert(!std::is_same_v<std::remove_cv_t<T>, void>,
                "invalid instantiation of class C for void type");

public:
  template <typename V> void f(V &&v) {
    if constexpr (std::is_reference_v<T>) {
      ... // special code if T is a reference type
    }
    if constexpr (std::is_convertible_v<std::decay_t<V>, T>) {
      ... // special code if V is convertible to T
    }
    if constexpr (std::has_virtual_destructor_v<V>) {
      ... // special code if V has virtual destructor
    }
  }
};
```

这里，我们使用 type_traits 来进行不同的实现。

### std::addressof()

可以使用`std::addressof<>()`获取对象或者函数**真实的地址**， 即使它重载了`operator &`. 不过这种情况不是很常见。当你想获取任意类型的真实地址时，推荐使用`std::addressof<>()：`

```cpp
template<typename T>
void f (T&& x) {
    auto p = &x;         // might fail with overloaded operator &
    auto q = std::addressof(x);       // works even with overloaded operator &
    ...
}
```

比如在 STL vector 中，当 vector 需要扩容时，迁移新旧 vector 元素的代码：

```cpp
{
  for (; __first != __last; ++__first, (void)++__cur) std::_Construct(std::__addressof(*__cur), *__first);
  return __cur;
}

template <typename _T1, typename... _Args>
inline void _Construct(_T1 *__p, _Args &&... __args) {
  ::new (static_cast<void *>(__p)) _T1(std::forward<_Args>(__args)...);      //实际copy(或者move)元素
}
```

这里使用`std::addressof()`获取新 vector 当前元素的地址，然后进行 copy(或 move)。可以看之前写的**c++ 从 vector 扩容看 noexcept 应用场景[2]**

### std::declval

**`std::declval`[3]**可以被视为某一特定类型对象引用的占位符。它不会创建对象，常常和 decltype 和 sizeof 搭配使用。因此，在不创建对象的情况下，可以假设有相应类型的可用对象，即使该类型没有默认构造函数或该类型不可以创建对象。

**注意，declval 只能在unevaluated contexts[4]中使用。**

一个简单的例子：

```cpp
class Foo;     //forward declaration
Foo f(int);     //ok. Foo is still incomplete
using f_result = decltype(f(11));      //f_result is Foo
```

现在如果我想获取使用 int 调用 f()后返回的类型是什么？是`decltype(f(11))`？看起来怪怪的，使用 declval 看起来就很明了：

```cpp
decltype(f(std::declval<int>()))
```

还有就是之前**c++11-17 模板核心知识（一）—— 函数模板[5]**中的例子)——返回多个模板参数的公共类型：

```cpp
template <typename T1, typename T2,
          typename RT = std::decay_t<decltype(true ? std::declval<T1>()
                                                   : std::declval<T2>())>>
RT max(T1 a, T2 b) {
  return b < a ? a : b;
}
```

这里在为了避免在`?:`中不得不去调用 T1 和 T2 的构造函数去创建对象，我们使用 declval 来避免创建对象，而且还可以达到目的。ps. 别忘了使用 std::decay_t，因为 declval 返回的是一个 rvalue references. 如果不用的话，`max(1,2)`会返回`int&&`.

最后看下官网的例子：

```cpp
#include <utility>
#include <iostream>

struct Default { int foo() const { return 1; } };

struct NonDefault
{
    NonDefault() = delete;
    int foo() const { return 1; }
};

int main()
{
    decltype(Default().foo()) n1 = 1;                   // type of n1 is int
//  decltype(NonDefault().foo()) n2 = n1;               // error: no default constructor
    decltype(std::declval<NonDefault>().foo()) n2 = n1;    // type of n2 is int
    std::cout << "n1 = " << n1 << '\n'
              << "n2 = " << n2 << '\n';
}
```

## 完美转发 Perfect Forwarding

```cpp
template<typename T>
void f (T&& t) // t is forwarding reference {
    g(std::forward<T>(t));       // perfectly forward passed argument t to g()
}
```

或者转发临时变量，避免无关的拷贝开销：

```cpp
template<typename T>
void foo(T x) {
    auto&& val = get(x);
    ...

    // perfectly forward the return value of get() to set():
    set(std::forward<decltype(val)>(val));
}
```

## 作为模板参数的引用

```cpp
template<typename T>
void tmplParamIsReference(T) {
    std::cout << "T is reference: " << std::is_reference_v<T> << '\n';
}

int main() {
    std::cout << std::boolalpha;
    int i;
    int& r = i;
    tmplParamIsReference(i);     // false
    tmplParamIsReference(r);      // false
    tmplParamIsReference<int&>(i);      // true
    tmplParamIsReference<int&>(r);      // true
}
```

这点也不太常见，在前面的文章 c++11-17 模板核心知识（七）—— 模板参数 按值传递 vs 按引用传递提到过一次。这个会改变强制改变模板的行为，即使模板的设计者一开始不想这么设计。

我没怎么见过这种用法，而且这种用法有的时候会有坑，大家了解一下就行。

可以使用 static_assert 禁止这种用法：

```cpp
template<typename T>
class optional {
    static_assert(!std::is_reference<T>::value, "Invalid instantiation of optional<T> for references");
    …
};
```

## 延迟计算 Defer Evaluations

首先引入一个概念：incomplete types. 类型可以是 complete 或者 incomplete，incomplete types 包含：

- 类只声明没有定义。
- 数组没有定义大小。
- 数组包含 incomplete types。
- void
- 枚举类型的 underlying type 或者枚举类型的值没有定义。

可以理解 incomplete types 为只是定义了一个标识符但是没有定义大小。例如：

```cpp
class C;     // C is an incomplete type
C const* cp;     // cp is a pointer to an incomplete type
extern C elems[10];     // elems has an incomplete type
extern int arr[];     // arr has an incomplete type
...
class C { };     // C now is a complete type (and therefore cpand elems no longer refer to an incomplete type)
int arr[10];     // arr now has a complete type
```

现在回到 Defer Evaluations 的主题上。考虑如下类模板：

```cpp
template<typename T>
class Cont {
  private:
    T* elems;
  public:
    ...
};
```

现在这个类可以使用 incomplete type，这在某些场景下很重要，例如链表节点的简单实现：

```cpp
struct Node {
    std::string value;
    Cont<Node> next;        // only possible if Cont accepts incomplete types
};
```

但是，一旦使用一些 type_traits，类就不再接受 incomplete type：

```cpp
template <typename T>
class Cont {
private:
  T *elems;

public:
  ...

  typename std::conditional<std::is_move_constructible<T>::value, T &&, T &>::type
  foo();
};
```

`std::conditional`也是一个 type_traits，这里的意思是：根据 T 是否支持移动语义，来决定 foo()返回`T &&`还是`T &`.

但是问题在于，`std::is_move_constructible`需要它的参数是一个 complete type. 所以，之前的 struct Node 这种声明会失败（不是所有的编译器都会失败。其实这里我理解不应该报错，因为按照类模板实例化的规则，成员函数只有用到的时候才进行实例化）。

我们可以使用 Defer Evaluations 来解决这个问题：

```cpp
template <typename T>
class Cont {
private:
  T *elems;

public:
  ...

  template<typename D = T>
  typename std::conditional<std::is_move_constructible<T>::value, T &&, T &>::type
  foo();
};
```

这样，编译器就会直到 foo()被 complete type 的 Node 调用时才实例化。

（完）

### 参考资料

1. [`std::invoke<>()`](https://en.cppreference.com/w/cpp/utility/functional/invoke)
2. [c++ 从 vector 扩容看 noexcept 应用场景](https://en.cppreference.com/w/cpp/utility/functional/invoke)
3. [`std::declval`](https://en.cppreference.com/w/cpp/utility/declval)
4. [unevaluated contexts](https://en.cppreference.com/w/cpp/language/expressions#Unevaluated_expressions)
5. c++11-17 模板核心知识（一）—— 函数模板

# （十二）—— 模板的模板参数

## 概念

一个模板的参数是模板类型。（Template Template Parameters）

## 举例

在**c++11-17 模板核心知识（二）—— 类模板[1]** 中，如果我们想要允许指定存储 Stack 元素的容器，是这么做的：

```cpp
template <typename T, typename Cont = std::vector<T>>
class Stack {
private:
  Cont elems; // elements
  ......
};
```

使用：

```cpp
Stack<double,std::deque<double>> dblStack;
```

但是这样的缺点是需要指定元素类型两次，然而这两个类型是一样的。

使用模板的模板参数（Template Template Parameters），允许我们在声明 Stack 类模板的时候只指定容器的类型而不去指定容器中 元素的类型。例如：

```cpp
template <typename T, template <typename Elem> class Cont = std::deque>
class Stack {
private:
  Cont<T> elems; // elements
public:
  void push(T const &); // push element
  void pop();           // pop element
  T const &top() const; // return top element
  bool empty() const {  // return whether the stack is empty
    return elems.empty();
  }
  ...
};
```

使用：

```cpp
Stack<int, std::vector> vStack;      // integer stack that uses a vector
```

与第一种方式的区别是：第二个模板参数是一个类模板：

```cpp
template<typename Elem> class Cont
```

默认值从`std::deque<T>`改为了`std::deque`.

在 C++17 之后，模板的模板参数中的 class 也可以使用 typename，但是不可以使用 struct 和 union：

```cpp
template <typename T,
          template <typename Elem> typename Cont = std::deque>
class Stack {       // ERROR before C++17
  ...
};

......

template<template<typename X> class C> // OK
void f(C<int>* p);

template<template<typename X> struct C> // ERROR: struct not valid here
void f(C<int>* p);

template<template<typename X> union C> // ERROR: union not valid here
void f(C<int>* p);
```

当然，由于模板的模板参数中的 Elem 没有用到，可以省略：

```cpp
template <typename T, template <typename> class Cont = std::deque>
class Stack {
  ...
};
```

**另外注意一点，模板的模板参数中的模板参数，只能和模板的模板参数配合用。有点饶，举个例子：**

```cpp
template<template<typename T, T*> class Buf>        // OK
class Lexer {
    static T* storage;        // ERROR: a template template parameter cannot be used here
    ...
};
```

## 模板的模板参数的参数匹配 Template Template Argument Matching

大家可以尝试自己编译一下上面的代码，可能会出现下列问题：

```cpp
error: template template argument has different template parameters than its corresponding template template parameter
template <typename T, template <typename Elem> class Cont = std::deque>

...

/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/deque:1197:1: note: too many template parameters in template template argument
template <class _Tp, class _Allocator /*= allocator<_Tp>*/>
```

意思是`std::deque`和`Cont`不匹配。标准库的`std::deque`有两个参数，还有一个默认参数 Allocator :

```cpp
template <class _Tp, class _Allocator = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS deque;
```

### 解决办法一

将 Cont 和 std::deque 的参数匹配即可：

```cpp
template <typename T,
          template <typename Elem, typename Alloc = std::allocator<Elem>>
          class Cont = std::deque>
class Stack {
......
};
```

这里的 Alloc 没有用到，同样可以省略。

成员函数定义举例：

```cpp
template<typename T, template<typename,typename> class Cont>
void Stack<T,Cont>::push (T const& elem) {
    elems.push_back(elem);       // append copy of passed elem
}
```

### 解决办法二

利用**c++11-17 模板核心知识（四）—— 可变参数模板 Variadic Template[2]**

```cpp
template <typename T,
          template <typename......>
          class Cont = std::deque>
class Stack {
......
};
```

但是，这点对于`std::array`无效，因为 std::array 的第二个参数是**非类型模板参数 Nontype Template Parameters[3]**:

```cpp
// template<typename T, size_t N>
// class array;
```

假如使用`Stack<int,std::array> s;`，那么编译器会报错：

```cpp
/Library/Developer/CommandLineTools/usr/bin/../include/c++/v1/array:126:29: note: template parameter has a different kind in template argument
template <class _Tp, size_t _Size>
                            ^
main.cc:22:33: note: previous template template parameter is here
          template <typename... Elem>
                                ^
```

(完)

### 参考资料

1. c++11-17 模板核心知识（二）—— 类模板
2. c++11-17 模板核心知识（四）—— 可变参数模板 Variadic Template
3. [非类型模板参数 Nontype Template Parameters](https://github.com/zhangyachen/zhangyachen.github.io/issues/153)

# （十三）—— 名称查找与ADL

在 C++中，如果编译器遇到一个名称，它会寻找这个名称代表什么。比如 x*y，如果 x 和 y 是变量的名称，那么就是乘法。如果 x 是一个类型的名称，那么就声明了一个指针。

C++是一个`context-sensitive`的语言 : 必须知道上下文才能知道表达式的意义。那么这个和模板的关系是什么呢？构造一个模板必须知道几个上下文：

- 模板出现的上下文
- 模板被实例化的上下文
- 实例化模板参数的上下文

## 名称分类

引入两个重要的概念：

- qualified name : 一个名称所属的作用域**被显式的指明**，例如`::`、`->`或者`.`。`this->count`就是一个 qualified name，但 count 不是，因为它的作用域没有被显示的指明，即使它和`this->count`是等价的。
- dependent name：依赖于模板参数的名称，也就是访问运算符左面的表达式类型依赖于模板参数。例如：std::vector<T>::iterator 是一个 Dependent Name，但假如 T 是一个已知类型的别名（using T = int），那就不是 Dependent Name。

![img](https://pic3.zhimg.com/80/v2-4db43a810b91f1f1b70be68ebe952cfa_720w.webp)

## 名称查找

名称查找有很多细节，这里我们只关注几个主要的点。

### ordinary lookup

对于 qualified name 来说，会有显示指明的作用域。如果作用域是一个类，那么基类也会被考虑在内，但是类的外围作用域不会被考虑：

```cpp
int x;

class B {
public:
  int i;
};

class D : public B {};

void f(D *pd) {
  pd->i = 3;    // finds B::i
  D::x = 2;      // ERROR: does not find ::x in the enclosing scope
}
```

这点很符合直觉。

相反，对于非 qualified name 来说，会在外围作用域逐层查找（假如在类成员函数中，会先找本类和基类的作用域）。**这叫做 ordinary lookup** :

```cpp
extern int count;             // #1

int lookup_example(int count) // #2
{
  if (count < 0) {
    int count = 1;           // #3
    lookup_example(count);   // unqualified count refers to #3
  }
  return count + ::count;      // the first (unqualified) count refers to #2 ;
}                              // the second (qualified) count refers to #1
```

这个例子也很符合直觉。

但是下面这个例子就没那么正常：

```cpp
template<typename T>
T max (T a, T b) {
    return b < a ? a : b;
}

namespace BigMath {
  class BigNumber {
    ...
};

  bool operator < (BigNumber const&, BigNumber const&);
  ...
}

using BigMath::BigNumber;

void g (BigNumber const& a, BigNumber const& b) {
  ...
  BigNumber x = ::max(a,b);
  ...
}
```

这里的问题是：当调用 max 时，`ordinary lookup`不会找到 BigNumber 的`operator <`。如果没有一些特殊规则，那么在 C++ namespace 场景中，会极大的限制模板的适应性。**ADL 就是这个特殊规则，用来解决此类的问题。**

### ADL (Argument-Dependent Lookup)

ADL 出现在 C++98/C++03 中，也被叫做 Koenig lookup，应用在非 qualified name 上（下文简称 unqualified name）。**在函数调用表达式[1]中（f(a1, a2, a3, ... )，包含隐式的调用重载 operator，例如 << ），ADL 应用一系列的规则来查找`unqualified function names`。**

ADL 会将函数表达式中实参的`associated namespaces`和`associated classes`加入到查找范围，这也就是为什么叫**Argument-Dependent** Lookup. 例如：某一类型是指向 class X 的指针，那么它的`associated namespaces`和`associated classes`会包含 X 和 X 所属的任何 class 和 namespace.

对于给定的类型，`associated classes`和`associated namespaces`按照一定的规则来定义，大家可以看下**官网 Argument-dependent lookup[2]**，实在有点多，不写在这里了。理解为什么需要 ADL、什么时候应用到 ADL 时，按照对应的场景再去查就行~

额外需要注意的一点是，ADL 会忽略 using :

```cpp
#include <iostream>

namespace X {
  template <typename T> void f(T);
}

namespace N {
  using namespace X;
  enum E { e1 };
  void f(E) { std::cout << "N::f(N::E) called\n"; }
}    // namespace N

void f(int) { std::cout << "::f(int) called\n"; }

int main() {
  ::f(N::e1);    // qualified function name: no ADL
  f(N::e1);     // ordinary lookup finds ::f() and ADL finds N::f(), the latter is preferred
}
```

`namespace N`中的`using namespace X`会被 ADL 忽略，所以在 main 函数中，X::f()不会被考虑。

### 官网的例子

看下**官网[3]**的例子帮助理解：

```cpp
#include <iostream>
int main() {
    std::cout << "Test\n"; // There is no operator<< in global namespace, but ADL
                           // examines std namespace because the left argument is in
                           // std and finds std::operator<<(std::ostream&, const char*)
    operator<<(std::cout, "Test\n"); // same, using function call notation

    // however,
    std::cout << endl; // Error: 'endl' is not declared in this namespace.
                       // This is not a function call to endl(), so ADL does not apply

    endl(std::cout); // OK: this is a function call: ADL examines std namespace
                     // because the argument of endl is in std, and finds std::endl

    (endl)(std::cout); // Error: 'endl' is not declared in this namespace.
                       // The sub-expression (endl) is not a function call expression
}
```

注意最后一点`(endl)(std::cout);`，如果函数的名字被括号包起来了，那也不会应用 ADL。

再来一个：

```cpp
namespace A {
      struct X;
      struct Y;
      void f(int);
      void g(X);
}

namespace B {
    void f(int i) {
        f(i);      // calls B::f (endless recursion)
    }
    void g(A::X x) {
        g(x);   // Error: ambiguous between B::g (ordinary lookup)
                //        and A::g (argument-dependent lookup)
    }
    void h(A::Y y) {
        h(y);   // calls B::h (endless recursion): ADL examines the A namespace
                // but finds no A::h, so only B::h from ordinary lookup is used
    }
}
```

这个比较好理解，不解释了。

### ADL 的缺点

依赖 ADL 有可能会导致语义问题，这也是为什么有的时候需要在函数前面加`::`，或者一般推荐使用 xxx::func，而不是 using namespace xxx 。因为前者是 qualified name，没有 ADL 的过程。

引用**现代 C++之 ADL[4]**中的例子，只看 swap 就行，类的其他函数可以略过：

```cpp
#include <iostream>

namespace A {
    template<typename T>
    class smart_ptr {
    public:
        smart_ptr() noexcept : ptr_(nullptr) {

        }

        smart_ptr(const T &ptr) noexcept : ptr_(new T(ptr)) {

        }

        smart_ptr(smart_ptr &rhs) noexcept {
            ptr_ = rhs.release();       // 释放所有权,此时rhs的ptr_指针为nullptr
        }

        smart_ptr &operator=(smart_ptr rhs) noexcept {
            swap(rhs);
            return *this;
        }

        void swap(smart_ptr &rhs) noexcept { // noexcept == throw() 保证不抛出异常
            using std::swap;
            swap(ptr_, rhs.ptr_);
        }

        T *release() noexcept {
            T *ptr = ptr_;
            ptr_ = nullptr;
            return ptr;
        }

        T *get() const noexcept {
            return ptr_;
        }

    private:
        T *ptr_;
    };

// 提供一个非成员swap函数for ADL(Argument Dependent Lookup)
    template<typename T>
    void swap(A::smart_ptr<T> &lhs, A::smart_ptr<T> &rhs) noexcept {
        lhs.swap(rhs);
    }
}

// 开启这个注释，会引发ADL冲突
//namespace std {
//    // 提供一个非成员swap函数for ADL(Argument Dependent Lookup)
//    template<typename T>
//    void swap(A::smart_ptr<T> &lhs, A::smart_ptr<T> &rhs) noexcept {
//        lhs.swap(rhs);
//    }
//
//}

int main() {

    using std::swap;
    A::smart_ptr<std::string> s1("hello"), s2("world");
    // 交换前
    std::cout << *s1.get() << " " << *s2.get() << std::endl;
    swap(s1, s2);      // 这里swap 能够通过Koenig搜索或者说ADL根据s1与s2的命名空间来查找swap函数
    // 交换后
    std::cout << *s1.get() << " " << *s2.get() << std::endl;
}
```

(完)

### 参考资料

1. 函数调用表达式: *[https://en.cppreference.com/w/cpp/language/operator_other](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/operator_other)*
2. 官网 Argument-dependent lookup: *[https://en.cppreference.com/w/cpp/language/adl](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/adl)*
3. 官网: *[https://en.cppreference.com/w/cpp/language/adl](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/adl)*
4. 现代 C++之 ADL: *[https://blog.csdn.net/guangchen](https://link.zhihu.com/?target=https%3A//blog.csdn.net/guangcheng0312q/article/details/103750458)*

# （十四）—— 解析模板之依赖型模板名称

标题超出字数限制了，完整的是：**c++11-17 模板核心知识（十四）—— 解析模板之依赖型模板名称 Dependent Names of Templates(.template/->template/::template)**



有时间的建议先看下上篇文章

## tokenization 与 parsing

绝大多数语言在编译的时候都有两个阶段：

- tokenization，或者叫 scanning/lexing
- parsing

tokenization 阶段会读取源码并生成一系列 token. 例如：`int *p = 0;`，tokenizer 会生成关键字 int、运算符*、标识符 p、运算符=、整数 0、运算符;

接下来，parser 会递归的减少标记，寻找已知的模式。例如：token 0 是一个合法的表达式，*p 组合也是一个合法的声明，它和后面的=0 组合也是一个合法**初始化声明**。最后，int 是一个已知的类型，后面跟着**初始化声明** : *p=0，所以，我们得到了一个初始化 p 的声明

## 解析模板之类型的依赖名称 Dependent Names of Templates

关于模板解析有六个大方面：

- 非模板中的上下文相关性 Context Sensitivity in Nontemplates
- 依赖型类型名称 Dependent Names of Types
- 依赖型模板名称 Dependent Names of Templates <-----
- using-declaration 中的依赖型名称 Dependent Names in Using Declarations
- ADL 和显式模板实参 ADL and Explicit Template Arguments
- 依赖性表达式 Dependent Expressions

这篇文章先讲下代码中比较常见的第三点 ： 依赖型模板名称（Dependent Names of Templates）

**这里有一个很重要的概念 ：** 在[c++11-17 模板核心知识（十三）—— 名称查找与 ADL](https://zhuanlan.zhihu.com/p/338917913)中介绍过的 Dependent Name：依赖于模板参数的名称，也就是访问运算符左面的表达式类型依赖于模板参数。例如：std::vector::iterator 是一个 Dependent Name，但假如 T 是一个已知类型的别名（using T = int），那就不是 Dependent Name。

通常而言， 编译器会把模板名称后面的<当做模板参数列表的开始，否则，<就是比较运算符。**但是，当引用的模板名称是 Dependent Name 时，编译器不会假定它是一个模板名称，除非显示的使用 template 关键字来指明**，模板代码中常见的`->template`、`.template`、`::template`就应用于这种场景中。

下面看几个例子。

### Example One

```cpp
template<unsigned long N>
void printBitset (std::bitset<N> const& bs) {
    std::cout << bs.template to_string<char, std::char_traits<char>, std::allocator<char>>();
}
```

这里，参数 bs 依赖于模板参数 N。所以，我们必须通过 template 关键字让编译器知道 bs 是一个模板名称，否则按照上面的规则，`<`会被当做比较符——小于号。

### Example Two

```cpp
#include <iostream>
using namespace std;

class X {
   public:
      template <int j> struct S {
         void h() {
            cout << "member template's member function: " << j << endl;
         }
      };
      template <int i> void f() {
        cout << "Primary: " << i << endl;
      }
};

template<> void X::f<20>() {
   cout << "Specialized, non-type argument = 20" << endl;
}

template<class T> void g(T* p) {
   p->template f<100>();
   p->template f<20>();
   typename T::template S<40> s; // use of scope operator on a member template
   s.h();
}

int main()
{
   X temp;
   g(&temp);
}
```

这里，参数 p 依赖模板参数 T。注意`typename T::template S<40> s;`的使用。

### Example Three

```cpp
template <typename T> class Shell {
public:
  template <int N> class In {
  public:
    template <int M> class Deep {
    public:
      virtual void f();
    };
  };
};

template <typename T, int N> class Weird {
public:
  void case1(typename Shell<T>::template In<N>::template Deep<N> *p) {
    p->template Deep<N>::f();      // inhibit virtual call
  }

  void case2(typename Shell<T>::template In<N>::template Deep<N> &p) {
    p.template Deep<N>::f();      // inhibit virtual call
  }
};
```

参数 p 依赖模板参数 T。编译器不会去判断`p.Deep`是不是模板。如果不指定 template，那么`p.Deep<N>::f()`就会被解析成`((p.Deep)<N)>f();`，`<`被当做比较符。

基于上面的例子，我们也可以知道，`->template`、`.template`、`::template`只存在于模板中，并且是在 Dependent Name 的场景下使用（依赖于模板参数）。

# （十五）—— 解析模板之依赖型类型名称

标题超过字数限制了，完整标题是：c++11-17 模板核心知识（十五）—— 解析模板之依赖型类型名称(Dependent Names of Types)与typename

上篇文章[c++11-17 模板核心知识（十四）—— 解析模板之依赖型模板名称 Dependent Names of Templates(.template/->template/::template)](https://zhuanlan.zhihu.com/p/339183858) 介绍了依赖型模板名称，提到关于模板解析有六个大方面：

- 非模板中的上下文相关性 Context Sensitivity in Nontemplates
- 依赖型类型名称 Dependent Names of Types <-----
- 依赖型模板名称 Dependent Names of Templates
- using-declaration中的依赖型名称 Dependent Names in Using Declarations
- ADL和显式模板实参 ADL and Explicit Template Arguments
- 依赖性表达式 Dependent Expressions

这篇文章介绍下依赖型类型名称（Dependent Names of Types）。

## 模板名称的问题及解决

模板中的名称存在一个问题：它们有的时候不能被很好的分类，比如一个模板引用其他模板的名称，因为模板特化的存在，会让问题变得复杂一些。例如：

```cpp
template <typename T> class Trap {
public:
  enum { x }; // #1 x is not a type here
};

template <typename T> class Victim {
public:
  int y;
  void poof() {
    Trap<T>::x *y; // #2 declaration or multiplication?
  }
};

template <> class Trap<void> { // evil specialization!
public:
  using x = int; // #3 x is a type here
};

void boom(Victim<void> &bomb) { bomb.poof(); }
```

如果你直接编译，会报错：

```cpp
main.cc:30:14: error: unexpected type name 'x': expected expression
    Trap<T>::x *y; // #2 declaration or multiplication?
             ^
main.cc:39:38: note: in instantiation of member function 'Victim<void>::poof' requested here
void boom(Victim<void> &bomb) { bomb.poof(); }
                                     ^
1 error generated.
```

这个问题和解决方案在**[c++11-17 模板核心知识（二）—— 类模板](https://link.zhihu.com/?target=https%3A//github.com/zhangyachen/zhangyachen.github.io/issues/152%23%E5%85%B3%E9%94%AE%E5%AD%97typename)**涉及过，这篇文章再展开说一下相关规则。

回到上面的例子，当编译器解析到#2处时，它需要决定`Trap<T>::x`是一个类型还是一个值，这决定了`Trap<T>::x *y`是声明一个指针还是做乘法。

问题是，在Trap中，`Trap<T>::x`是一个值，但是在全特化版本`Trap<void>`中，`Trap<T>::x`是一个类型。所以，这种情况实际是依赖模板参数T的，也就是依赖型类型名称（Dependent Names of Types）。

C++规定，只有当加上typename关键字后，**依赖型类型名称**才会被当做类型，否则会被当做一个值。这里typename的意义和声明一个模板时使用的typename是两个意思，所以不能用class来替换typename.

## typename规则

当一个名称具备以下性质时，需要在名称前面加typename：

- 是qualified name。
- 不是**[Elaborated type specifier](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/elaborated_type_specifier)**的一部分（例如，以class、struct、union、enum为开头的类型）
- 名称不是**用于指定基类继承的列表**中，也不是位于**引入构造函数的成员初始化列表**中。
- 依赖于模板参数。

例如：

```cpp
template <typename(1) T> 
struct S : typename(2) X<T>::Base {
  S() : typename(3) X<T>::Base(typename(4) X<T>::Base(0)) {}
  
  typename(5) X<T> f() {
    typename(6) X<T>::C *p; // declaration of pointer p
    X<T>::D *q;           // multiplication!
  }
  typename(7) X<int>::C *s;

  using Type = T;
  using OtherType = typename(8) S<T>::Type;
};
```

下面逐一说下上面各个typename的使用场景(**有的使用方式是错误的**)：

- 第一个typename代表一个模板参数，不在此文章讨论范围内。
- 第二和第三个typename是错误的使用方式，不需要添加，违反了上面的第3条规则。第二个出现在了指定基类继承的列表中，第三个出现在了构造函数的成员初始化列表。如果加上typename编译，会报如下错误：

```cpp
main.cc:30:12: error: 'typename' is redundant; base classes are implicitly types
struct S : typename X<T>::Base {
           ^~~~~~~~~
```

- 第四个typename是必须的，它满足上面第3条规则，且其他规则也满足。
- 第五个typename是错误的，因为X不是一个qualified name，如果加上typename编译，会报：

```cpp
main.cc:33:12: error: expected a qualified name after 'typename'
  typename X<T> f() {
           ^
```

- 第六个typename是必须的，上面讲过，代表一个类型。
- 第七个typename是可有可无的，因为`X<int>::C`不依赖模板参数，即不是Dependent Name.
- 第八个typename也是可有可无的，因为它指向的是`current instantiation`，这个概念下篇文章会讲到。

## C++20 typename

是了，这一大堆乱七八糟的规则，谁也不想去记。C++20对typename的规则做了一些改善，有一些场景不再需要typename。详情大家可以参考 ： **[The typename disambiguator for dependent names](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/dependent_name%23The_typename_disambiguator_for_dependent_names)**

![img](https://pic3.zhimg.com/80/v2-57bc3cf35ebc1073511caf301e6ba786_720w.webp)
